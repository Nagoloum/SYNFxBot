[
    {
        "label": "streamlit",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "streamlit",
        "description": "streamlit",
        "detail": "streamlit",
        "documentation": {}
    },
    {
        "label": "st_autorefresh",
        "importPath": "streamlit_autorefresh",
        "description": "streamlit_autorefresh",
        "isExtraImport": true,
        "detail": "streamlit_autorefresh",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "plotly.express",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "plotly.express",
        "description": "plotly.express",
        "detail": "plotly.express",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "MongoClient",
        "importPath": "pymongo",
        "description": "pymongo",
        "isExtraImport": true,
        "detail": "pymongo",
        "documentation": {}
    },
    {
        "label": "MongoClient",
        "importPath": "pymongo",
        "description": "pymongo",
        "isExtraImport": true,
        "detail": "pymongo",
        "documentation": {}
    },
    {
        "label": "MetaTrader5",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "MetaTrader5",
        "description": "MetaTrader5",
        "detail": "MetaTrader5",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "ACCOUNT_NUMBER",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "PASSWORD",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "SERVER",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "MT5_TERMINAL_PATH",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "MONGODB_URI",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "DB_NAME",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "COLLECTION_NAME",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "SYMBOL",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "LOT_SIZE",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "SYMBOL",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "MAGIC_NUMBER",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "START_HOUR",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "END_HOUR",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "TELEGRAM_TOKEN",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "TELEGRAM_CHAT_ID",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "send_telegram_alert",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "setup_logging",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "send_telegram_alert",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "send_telegram_alert",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "init_db",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "save_open",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "collection",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "connect_to_mt5",
        "importPath": "connexion",
        "description": "connexion",
        "isExtraImport": true,
        "detail": "connexion",
        "documentation": {}
    },
    {
        "label": "disconnect",
        "importPath": "connexion",
        "description": "connexion",
        "isExtraImport": true,
        "detail": "connexion",
        "documentation": {}
    },
    {
        "label": "close_partial_v100",
        "importPath": "strategy",
        "description": "strategy",
        "isExtraImport": true,
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "get_smart_signal",
        "importPath": "strategy",
        "description": "strategy",
        "isExtraImport": true,
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "get_smart_signal",
        "importPath": "strategy",
        "description": "strategy",
        "isExtraImport": true,
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "handle_trade_closure",
        "importPath": "strategy",
        "description": "strategy",
        "isExtraImport": true,
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "is_volatility_good",
        "importPath": "strategy",
        "description": "strategy",
        "isExtraImport": true,
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "move_sl_to_be",
        "importPath": "strategy",
        "description": "strategy",
        "isExtraImport": true,
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "open_trade_v100",
        "importPath": "strategy",
        "description": "strategy",
        "isExtraImport": true,
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "pandas_ta",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas_ta",
        "description": "pandas_ta",
        "detail": "pandas_ta",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "asyncio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "asyncio",
        "description": "asyncio",
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "Bot",
        "importPath": "telegram",
        "description": "telegram",
        "isExtraImport": true,
        "detail": "telegram",
        "documentation": {}
    },
    {
        "label": "get_db_collection",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def get_db_collection():\n    uri = os.getenv(\"MONGODB_URI\")\n    client = MongoClient(uri)\n    db = client[\"SYNTHBOT\"]\n    return db[\"trades_v100\"]\ncollection = get_db_collection()\n# --- CHARGEMENT DES DONN√âES ---\n@st.cache_data(ttl=10)\ndef load_trades():\n    trades = list(collection.find().sort(\"open_time\", -1))",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "load_trades",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def load_trades():\n    trades = list(collection.find().sort(\"open_time\", -1))\n    if not trades:\n        return pd.DataFrame()\n    df = pd.DataFrame(trades)\n    # Conversion forc√©e en datetime\n    if \"open_time\" in df.columns:\n        df[\"open_time\"] = pd.to_datetime(df[\"open_time\"])\n    if \"close_time\" in df.columns:\n        df[\"close_time\"] = pd.to_datetime(df[\"close_time\"])",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "style_profit",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def style_profit(val):\n    return f'color: {\"red\" if val < 0 else \"green\"}'\nst.dataframe(\n    df[available].style.applymap(style_profit, subset=['profit']),\n    use_container_width=True\n)",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "collection",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "collection = get_db_collection()\n# --- CHARGEMENT DES DONN√âES ---\n@st.cache_data(ttl=10)\ndef load_trades():\n    trades = list(collection.find().sort(\"open_time\", -1))\n    if not trades:\n        return pd.DataFrame()\n    df = pd.DataFrame(trades)\n    # Conversion forc√©e en datetime\n    if \"open_time\" in df.columns:",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "df_raw",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "df_raw = load_trades()\n# --- BARRE LAT√âRALE (FILTRES) ---\nwith st.sidebar:\n    st.title(\"üìà Volatility 100 Index\")\n    st.title(\"‚öôÔ∏è Filtres Statistiques\")\n    # 1. Filtre de P√©riode\n    periode = st.selectbox(\n        \"Choisir la p√©riode\",\n        [\"Tout\", \"Aujourd'hui\", \"Cette Semaine\", \"Ce Mois\", \"Cette Ann√©e\"]\n    )",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "df = df_raw.copy()\nif not df.empty:\n    now = datetime.now()\n    if periode == \"Aujourd'hui\":\n        # Filtrer depuis minuit (00:00:00)\n        start_date = now.replace(hour=0, minute=0, second=0, microsecond=0)\n        df = df[df[\"open_time\"] >= start_date]\n    elif periode == \"Cette Semaine\":\n        # Filtrer les 7 derniers jours\n        start_date = now - timedelta(days=7)",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "total_trades",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "total_trades = len(df)\nwins = len(df[df[\"profit\"] > 0])\nwin_rate = (wins / total_trades * 100) if total_trades > 0 else 0\nnet_profit = df[\"profit\"].sum()\navg_profit = df[\"profit\"].mean() if total_trades > 0 else 0\ncol1.metric(\"Trades\", total_trades)\ncol2.metric(\"Win Rate\", f\"{win_rate:.1f}%\")\ncol3.metric(\"Profit Net\", f\"{net_profit:.2f} USD\")\ncol4.metric(\"Moyenne/Trade\", f\"{avg_profit:+.2f} USD\")\n# --- GRAPHIQUE ---",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "wins",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "wins = len(df[df[\"profit\"] > 0])\nwin_rate = (wins / total_trades * 100) if total_trades > 0 else 0\nnet_profit = df[\"profit\"].sum()\navg_profit = df[\"profit\"].mean() if total_trades > 0 else 0\ncol1.metric(\"Trades\", total_trades)\ncol2.metric(\"Win Rate\", f\"{win_rate:.1f}%\")\ncol3.metric(\"Profit Net\", f\"{net_profit:.2f} USD\")\ncol4.metric(\"Moyenne/Trade\", f\"{avg_profit:+.2f} USD\")\n# --- GRAPHIQUE ---\nst.subheader(\"√âvolution du Profit\")",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "win_rate",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "win_rate = (wins / total_trades * 100) if total_trades > 0 else 0\nnet_profit = df[\"profit\"].sum()\navg_profit = df[\"profit\"].mean() if total_trades > 0 else 0\ncol1.metric(\"Trades\", total_trades)\ncol2.metric(\"Win Rate\", f\"{win_rate:.1f}%\")\ncol3.metric(\"Profit Net\", f\"{net_profit:.2f} USD\")\ncol4.metric(\"Moyenne/Trade\", f\"{avg_profit:+.2f} USD\")\n# --- GRAPHIQUE ---\nst.subheader(\"√âvolution du Profit\")\ndf_sorted = df.sort_values(\"open_time\")",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "net_profit",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "net_profit = df[\"profit\"].sum()\navg_profit = df[\"profit\"].mean() if total_trades > 0 else 0\ncol1.metric(\"Trades\", total_trades)\ncol2.metric(\"Win Rate\", f\"{win_rate:.1f}%\")\ncol3.metric(\"Profit Net\", f\"{net_profit:.2f} USD\")\ncol4.metric(\"Moyenne/Trade\", f\"{avg_profit:+.2f} USD\")\n# --- GRAPHIQUE ---\nst.subheader(\"√âvolution du Profit\")\ndf_sorted = df.sort_values(\"open_time\")\ndf_sorted[\"cum_profit\"] = df_sorted[\"profit\"].cumsum()",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "avg_profit",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "avg_profit = df[\"profit\"].mean() if total_trades > 0 else 0\ncol1.metric(\"Trades\", total_trades)\ncol2.metric(\"Win Rate\", f\"{win_rate:.1f}%\")\ncol3.metric(\"Profit Net\", f\"{net_profit:.2f} USD\")\ncol4.metric(\"Moyenne/Trade\", f\"{avg_profit:+.2f} USD\")\n# --- GRAPHIQUE ---\nst.subheader(\"√âvolution du Profit\")\ndf_sorted = df.sort_values(\"open_time\")\ndf_sorted[\"cum_profit\"] = df_sorted[\"profit\"].cumsum()\nfig = px.area(df_sorted, x=\"open_time\", y=\"cum_profit\", ",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "df_sorted",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "df_sorted = df.sort_values(\"open_time\")\ndf_sorted[\"cum_profit\"] = df_sorted[\"profit\"].cumsum()\nfig = px.area(df_sorted, x=\"open_time\", y=\"cum_profit\", \n              labels={\"cum_profit\": \"Profit (USD)\", \"open_time\": \"Date\"},\n              color_discrete_sequence=[\"#00CC96\"])\nst.plotly_chart(fig, use_container_width=True)\n# --- TABLEAU ---\nst.subheader(\"D√©tails des Positions\")\ndisplay_cols = [\"ticket\", \"type\", \"open_price\", \"close_price\", \"profit\", \"status\", \"open_time\"]\navailable = [c for c in display_cols if c in df.columns]",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "df_sorted[\"cum_profit\"]",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "df_sorted[\"cum_profit\"] = df_sorted[\"profit\"].cumsum()\nfig = px.area(df_sorted, x=\"open_time\", y=\"cum_profit\", \n              labels={\"cum_profit\": \"Profit (USD)\", \"open_time\": \"Date\"},\n              color_discrete_sequence=[\"#00CC96\"])\nst.plotly_chart(fig, use_container_width=True)\n# --- TABLEAU ---\nst.subheader(\"D√©tails des Positions\")\ndisplay_cols = [\"ticket\", \"type\", \"open_price\", \"close_price\", \"profit\", \"status\", \"open_time\"]\navailable = [c for c in display_cols if c in df.columns]\ndef style_profit(val):",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "fig",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "fig = px.area(df_sorted, x=\"open_time\", y=\"cum_profit\", \n              labels={\"cum_profit\": \"Profit (USD)\", \"open_time\": \"Date\"},\n              color_discrete_sequence=[\"#00CC96\"])\nst.plotly_chart(fig, use_container_width=True)\n# --- TABLEAU ---\nst.subheader(\"D√©tails des Positions\")\ndisplay_cols = [\"ticket\", \"type\", \"open_price\", \"close_price\", \"profit\", \"status\", \"open_time\"]\navailable = [c for c in display_cols if c in df.columns]\ndef style_profit(val):\n    return f'color: {\"red\" if val < 0 else \"green\"}'",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "display_cols",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "display_cols = [\"ticket\", \"type\", \"open_price\", \"close_price\", \"profit\", \"status\", \"open_time\"]\navailable = [c for c in display_cols if c in df.columns]\ndef style_profit(val):\n    return f'color: {\"red\" if val < 0 else \"green\"}'\nst.dataframe(\n    df[available].style.applymap(style_profit, subset=['profit']),\n    use_container_width=True\n)",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "available",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "available = [c for c in display_cols if c in df.columns]\ndef style_profit(val):\n    return f'color: {\"red\" if val < 0 else \"green\"}'\nst.dataframe(\n    df[available].style.applymap(style_profit, subset=['profit']),\n    use_container_width=True\n)",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "ACCOUNT_NUMBER",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "ACCOUNT_NUMBER = int(os.getenv(\"ACCOUNT_NUMBER\", \"0\"))\nPASSWORD = os.getenv(\"PASSWORD\", \"\")\nSERVER = os.getenv(\"SERVER\", \"\")\nMT5_TERMINAL_PATH = r\"C:\\Program Files\\MetaTrader 5\\terminal64.exe\"\n# Uniquement V100\nSYMBOL = \"Volatility 100 Index\"\nLOT_SIZE = 1.0  # Volume fixe pour le test\nMAGIC_NUMBER = 123456\n# Telegram\nTELEGRAM_TOKEN = os.getenv(\"TELEGRAM_TOKEN\", \"\")",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "PASSWORD",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "PASSWORD = os.getenv(\"PASSWORD\", \"\")\nSERVER = os.getenv(\"SERVER\", \"\")\nMT5_TERMINAL_PATH = r\"C:\\Program Files\\MetaTrader 5\\terminal64.exe\"\n# Uniquement V100\nSYMBOL = \"Volatility 100 Index\"\nLOT_SIZE = 1.0  # Volume fixe pour le test\nMAGIC_NUMBER = 123456\n# Telegram\nTELEGRAM_TOKEN = os.getenv(\"TELEGRAM_TOKEN\", \"\")\nTELEGRAM_CHAT_ID = os.getenv(\"TELEGRAM_CHAT_ID\", \"\")",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "SERVER",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "SERVER = os.getenv(\"SERVER\", \"\")\nMT5_TERMINAL_PATH = r\"C:\\Program Files\\MetaTrader 5\\terminal64.exe\"\n# Uniquement V100\nSYMBOL = \"Volatility 100 Index\"\nLOT_SIZE = 1.0  # Volume fixe pour le test\nMAGIC_NUMBER = 123456\n# Telegram\nTELEGRAM_TOKEN = os.getenv(\"TELEGRAM_TOKEN\", \"\")\nTELEGRAM_CHAT_ID = os.getenv(\"TELEGRAM_CHAT_ID\", \"\")\n# MongoDB",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "MT5_TERMINAL_PATH",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "MT5_TERMINAL_PATH = r\"C:\\Program Files\\MetaTrader 5\\terminal64.exe\"\n# Uniquement V100\nSYMBOL = \"Volatility 100 Index\"\nLOT_SIZE = 1.0  # Volume fixe pour le test\nMAGIC_NUMBER = 123456\n# Telegram\nTELEGRAM_TOKEN = os.getenv(\"TELEGRAM_TOKEN\", \"\")\nTELEGRAM_CHAT_ID = os.getenv(\"TELEGRAM_CHAT_ID\", \"\")\n# MongoDB\nMONGODB_URI = os.getenv(\"MONGODB_URI\", \"\")",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "SYMBOL",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "SYMBOL = \"Volatility 100 Index\"\nLOT_SIZE = 1.0  # Volume fixe pour le test\nMAGIC_NUMBER = 123456\n# Telegram\nTELEGRAM_TOKEN = os.getenv(\"TELEGRAM_TOKEN\", \"\")\nTELEGRAM_CHAT_ID = os.getenv(\"TELEGRAM_CHAT_ID\", \"\")\n# MongoDB\nMONGODB_URI = os.getenv(\"MONGODB_URI\", \"\")\nDB_NAME = os.getenv(\"MONGODB_DB\", \"trading_bot_V100\")\nCOLLECTION_NAME = \"trades_v100\"",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "LOT_SIZE",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "LOT_SIZE = 1.0  # Volume fixe pour le test\nMAGIC_NUMBER = 123456\n# Telegram\nTELEGRAM_TOKEN = os.getenv(\"TELEGRAM_TOKEN\", \"\")\nTELEGRAM_CHAT_ID = os.getenv(\"TELEGRAM_CHAT_ID\", \"\")\n# MongoDB\nMONGODB_URI = os.getenv(\"MONGODB_URI\", \"\")\nDB_NAME = os.getenv(\"MONGODB_DB\", \"trading_bot_V100\")\nCOLLECTION_NAME = \"trades_v100\"\nSTART_HOUR = 8 ",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "MAGIC_NUMBER",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "MAGIC_NUMBER = 123456\n# Telegram\nTELEGRAM_TOKEN = os.getenv(\"TELEGRAM_TOKEN\", \"\")\nTELEGRAM_CHAT_ID = os.getenv(\"TELEGRAM_CHAT_ID\", \"\")\n# MongoDB\nMONGODB_URI = os.getenv(\"MONGODB_URI\", \"\")\nDB_NAME = os.getenv(\"MONGODB_DB\", \"trading_bot_V100\")\nCOLLECTION_NAME = \"trades_v100\"\nSTART_HOUR = 8 \nEND_HOUR = 20",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "TELEGRAM_TOKEN",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "TELEGRAM_TOKEN = os.getenv(\"TELEGRAM_TOKEN\", \"\")\nTELEGRAM_CHAT_ID = os.getenv(\"TELEGRAM_CHAT_ID\", \"\")\n# MongoDB\nMONGODB_URI = os.getenv(\"MONGODB_URI\", \"\")\nDB_NAME = os.getenv(\"MONGODB_DB\", \"trading_bot_V100\")\nCOLLECTION_NAME = \"trades_v100\"\nSTART_HOUR = 8 \nEND_HOUR = 20",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "TELEGRAM_CHAT_ID",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "TELEGRAM_CHAT_ID = os.getenv(\"TELEGRAM_CHAT_ID\", \"\")\n# MongoDB\nMONGODB_URI = os.getenv(\"MONGODB_URI\", \"\")\nDB_NAME = os.getenv(\"MONGODB_DB\", \"trading_bot_V100\")\nCOLLECTION_NAME = \"trades_v100\"\nSTART_HOUR = 8 \nEND_HOUR = 20",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "MONGODB_URI",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "MONGODB_URI = os.getenv(\"MONGODB_URI\", \"\")\nDB_NAME = os.getenv(\"MONGODB_DB\", \"trading_bot_V100\")\nCOLLECTION_NAME = \"trades_v100\"\nSTART_HOUR = 8 \nEND_HOUR = 20",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "DB_NAME",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "DB_NAME = os.getenv(\"MONGODB_DB\", \"trading_bot_V100\")\nCOLLECTION_NAME = \"trades_v100\"\nSTART_HOUR = 8 \nEND_HOUR = 20",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "COLLECTION_NAME",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "COLLECTION_NAME = \"trades_v100\"\nSTART_HOUR = 8 \nEND_HOUR = 20",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "START_HOUR",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "START_HOUR = 8 \nEND_HOUR = 20",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "END_HOUR",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "END_HOUR = 20",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "connect_to_mt5",
        "kind": 2,
        "importPath": "connexion",
        "description": "connexion",
        "peekOfCode": "def connect_to_mt5(max_retries=3, delay=5):\n    \"\"\"Connexion MT5 avec retries\"\"\"\n    terminal_path = MT5_TERMINAL_PATH\n    for attempt in range(1, max_retries + 1):\n        try:\n            if mt5.terminal_info():\n                mt5.shutdown()\n                time.sleep(1)\n            # logging.info(f\"Tentative connexion {attempt}/{max_retries}\")\n            if not mt5.initialize(path=terminal_path):",
        "detail": "connexion",
        "documentation": {}
    },
    {
        "label": "disconnect",
        "kind": 2,
        "importPath": "connexion",
        "description": "connexion",
        "peekOfCode": "def disconnect():\n    \"\"\"D√©connexion\"\"\"\n    try:\n        if mt5.terminal_info():\n            mt5.shutdown()\n        logging.info(\"Bot arr√™t√©\")\n        send_telegram_alert(\"üõë Bot arr√™t√©\", force=True)  # Alert close\n    except Exception as e:\n        logging.error(f\"Erreur d√©connexion : {e}\")",
        "detail": "connexion",
        "documentation": {}
    },
    {
        "label": "init_db",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def init_db():\n    global collection\n    try:\n        client = MongoClient(MONGODB_URI, serverSelectionTimeoutMS=5000)\n        collection = client[DB_NAME][COLLECTION_NAME]\n        # logging.info(\"üíæ MongoDB : Connect√©\")\n    except Exception as e:\n        logging.error(f\"‚ùå Erreur MongoDB : {e}\")\n# database.py\ndef save_open(ticket, type_trade, price): # Ajoute type_trade ici",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "save_open",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def save_open(ticket, type_trade, price): # Ajoute type_trade ici\n    if collection is not None:\n        try:\n            collection.insert_one({\n                \"ticket\": ticket, \n                \"type\": type_trade, # Utilise l'argument re√ßu\n                \"open_price\": float(price),\n                \"open_time\": datetime.utcnow(), \n                \"status\": \"OPEN\"\n            })",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "save_close",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def save_close(ticket, profit, price):\n    if collection is not None:\n        collection.update_one(\n            {\"ticket\": ticket},\n            {\"$set\": {\"close_price\": price, \"close_time\": datetime.utcnow(), \"profit\": profit, \"status\": \"CLOSED\"}}\n        )",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "collection",
        "kind": 5,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "collection = None\ndef init_db():\n    global collection\n    try:\n        client = MongoClient(MONGODB_URI, serverSelectionTimeoutMS=5000)\n        collection = client[DB_NAME][COLLECTION_NAME]\n        # logging.info(\"üíæ MongoDB : Connect√©\")\n    except Exception as e:\n        logging.error(f\"‚ùå Erreur MongoDB : {e}\")\n# database.py",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "monitor_active_trade",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def monitor_active_trade(ticket, lot, signal_data):\n    \"\"\"\n    Surveille la position ouverte en temps r√©el pour g√©rer :\n    1. La cl√¥ture partielle (50% du volume)\n    2. Le passage en Break-Even (s√©curisation du SL)\n    3. La d√©tection de cl√¥ture finale (SL ou TP touch√©)\n    \"\"\"\n    half_done = False\n    print(f\"üëÄ Surveillance active du ticket {ticket} lanc√©e...\")\n    while True:",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "get_price_data",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def get_price_data(symbol, timeframe, n_bars=300):\n    \"\"\"R√©cup√®re les donn√©es OHLCV\"\"\"\n    rates = mt5.copy_rates_from_pos(symbol, timeframe, 0, n_bars)\n    if rates is None or len(rates) == 0:\n        return pd.DataFrame()\n    df = pd.DataFrame(rates)\n    df['time'] = pd.to_datetime(df['time'], unit='s')\n    return df\ndef get_zigzag(df, depth=10, zz_column_name='zz'):\n    zz_result = ta.zigzag(high=df['high'], low=df['low'], depth=depth)",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "get_zigzag",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def get_zigzag(df, depth=10, zz_column_name='zz'):\n    zz_result = ta.zigzag(high=df['high'], low=df['low'], depth=depth)\n    if isinstance(zz_result, pd.Series):\n        df[zz_column_name] = zz_result\n    elif isinstance(zz_result, pd.DataFrame):\n        # Prendre la colonne qui contient le plus de valeurs non-null\n        best_col = zz_result.notna().sum().idxmax()\n        df[zz_column_name] = zz_result[best_col]\n        # logging.info(f\"Colonne zigzag s√©lectionn√©e automatiquement : {best_col}\")\n    else:",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "detect_advanced_patterns",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def detect_advanced_patterns(df):\n    \"\"\"D√©tection simple W / M via ZigZag\"\"\"\n    peaks = get_zigzag(df)\n    if len(peaks) < 5:\n        return None\n    p = peaks['zz'].values\n    # Double Bottom (W)\n    if p[-1] > p[-2] and abs(p[-2] - p[-4]) < (p[-1] * 0.002) and p[-3] > p[-2]:\n        return \"DOUBLE_BOTTOM_W\"\n    # Double Top (M)",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "analyze_market_structure",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def analyze_market_structure(df):\n    \"\"\"√âtat du march√© : tendance ou range (M30 ou H1 recommand√©)\"\"\"\n    if len(df) < 50:\n        return \"INSUFFISANT\", 0, 0\n    adx = ta.adx(df['high'], df['low'], df['close'], length=14)\n    current_adx = adx['ADX_14'].iloc[-1]\n    resistance = df['high'].rolling(window=20).max().iloc[-1]\n    support    = df['low'].rolling(window=20).min().iloc[-1]\n    if current_adx < 22:\n        return \"ACCUMULATION (RANGE)\", support, resistance",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "get_market_trend_h4",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def get_market_trend_h4():\n    \"\"\"Filtre de tendance haute timeframe (H4)\"\"\"\n    df = get_price_data(SYMBOL, mt5.TIMEFRAME_H4, 100)\n    if df.empty:\n        return \"NEUTRAL\"\n    df['ema_50'] = ta.ema(df['close'], length=EMA_PERIOD_H4)\n    return \"UP\" if df['close'].iloc[-1] > df['ema_50'].iloc[-1] else \"DOWN\"\ndef check_fvg(df):\n    \"\"\"Fair Value Gap simple sur les 3 derni√®res bougies\"\"\"\n    if len(df) < 3:",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "check_fvg",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def check_fvg(df):\n    \"\"\"Fair Value Gap simple sur les 3 derni√®res bougies\"\"\"\n    if len(df) < 3:\n        return False, None\n    if df['high'].iloc[-3] < df['low'].iloc[-1]:\n        return True, \"BULLISH\"\n    if df['low'].iloc[-3] > df['high'].iloc[-1]:\n        return True, \"BEARISH\"\n    return False, None\ndef analyze_amd_priority(symbol):",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "analyze_amd_priority",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def analyze_amd_priority(symbol):\n    \"\"\"Priorise l'accumulation ‚Üí manipulation sur les TF hautes\"\"\"\n    tfs = [\n        (mt5.TIMEFRAME_H4,  \"H4\"),\n        (mt5.TIMEFRAME_H1,  \"H1\"),\n        (mt5.TIMEFRAME_M30, \"M30\")\n    ]\n    for tf_val, tf_name in tfs:\n        df = get_price_data(symbol, tf_val, 120)\n        if df.empty:",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "get_smart_signal",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def get_smart_signal():\n    \"\"\"\n    Strat√©gie principale ‚Äì Ordre de priorit√© :\n      1. AMD Manipulation (H4 > H1 > M30)\n      2. Figures chartistes W/M sur M5\n      3. Rebond sur support dynamique M5\n      4. (optionnel) Structure + OTE + FVG align√©s\n    \"\"\"\n    # ‚îÄ‚îÄ 1. Priorit√© AMD Manipulation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    amd_signal = analyze_amd_priority(SYMBOL)",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "find_swings",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def find_swings(df):\n    \"\"\"Identifie les fractales pour Fibonacci\"\"\"\n    df['high_swing'] = df['high'][(df['high'] == df['high'].rolling(11, center=True).max())]\n    df['low_swing'] = df['low'][(df['low'] == df['low'].rolling(11, center=True).min())]\n    try:\n        last_low = df['low_swing'].dropna().iloc[-1]\n        last_high = df['high_swing'].dropna().iloc[-1]\n        return last_low, last_high\n    except IndexError:\n        return None, None",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "open_trade_v100",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def open_trade_v100(signal):\n    \"\"\"Ex√©cute l'ordre et notifie la console/bot avec d√©tails lot et prix\"\"\"\n    tick = mt5.symbol_info_tick(SYMBOL)\n    lot = float(max(MIN_LOT_V100, 1.0)) # S√©curit√© lot minimum\n    price = tick.ask if signal['type'] == \"BUY\" else tick.bid\n    request = {\n        \"action\": mt5.TRADE_ACTION_DEAL,\n        \"symbol\": SYMBOL,\n        \"volume\": lot,\n        \"type\": mt5.ORDER_TYPE_BUY if signal['type'] == \"BUY\" else mt5.ORDER_TYPE_SELL,",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "update_db_profit",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def update_db_profit(ticket, profit, close_price, status=\"CLOSED\"):\n    \"\"\"Met √† jour MongoDB en ajoutant le profit (g√®re partiels et BE)\"\"\"\n    collection.update_one(\n        {\"ticket\": ticket},\n        {\"$inc\": {\"profit\": float(profit)}, \n         \"$set\": {\"close_price\": float(close_price), \"status\": status, \"close_time\": datetime.utcnow()}}\n    )\ndef handle_trade_closure(ticket, lot, reason):\n    \"\"\"Notification finale lors du SL ou TP avec profit r√©el BD\"\"\"\n    # Attendre la synchro historique",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "handle_trade_closure",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def handle_trade_closure(ticket, lot, reason):\n    \"\"\"Notification finale lors du SL ou TP avec profit r√©el BD\"\"\"\n    # Attendre la synchro historique\n    time.sleep(1)\n    history = mt5.history_deals_get(position=ticket)\n    if history:\n        total_profit = sum(deal.profit for deal in history)\n        msg = (f\"üèÅ TRADE TERMINE ({reason})\\nTicket: {ticket} | Lot: {lot}\\n\"\n               f\"R√©sultat Final: {total_profit:.2f} USD\")\n        print(f\"\\n--- CLOTURE ---\\n{msg}\\n---------------\\n\")",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "close_partial_v100",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def close_partial_v100(ticket, vol):\n    \"\"\"Ferme 50% et notifie le retrait partiel\"\"\"\n    pos_list = mt5.positions_get(ticket=ticket)\n    if not pos_list: return False\n    pos = pos_list[0]\n    tick = mt5.symbol_info_tick(SYMBOL)\n    request = {\n        \"action\": mt5.TRADE_ACTION_DEAL,\n        \"symbol\": SYMBOL,\n        \"volume\": float(vol),",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "move_sl_to_be",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def move_sl_to_be(ticket):\n    \"\"\"D√©place le SL au prix d'entr√©e (Break-Even)\"\"\"\n    pos_list = mt5.positions_get(ticket=ticket)\n    if not pos_list: return False\n    pos = pos_list[0]\n    request = {\n        \"action\": mt5.TRADE_ACTION_SLTP,\n        \"position\": ticket,\n        \"sl\": pos.price_open,\n        \"tp\": pos.tp",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "is_volatility_good",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def is_volatility_good():\n    \"\"\"V√©rifie l'heure et la volatilit√© via l'ATR\"\"\"\n    now = datetime.utcnow().hour\n    # 1. V√©rification Horaire\n    if not (START_HOUR <= now < END_HOUR):\n        msg = f\"‚è≥ March√© hors session : {now}h GMT. Bonne volatilit√© entre {START_HOUR}h et {END_HOUR}h GMT.\"\n        return False, msg\n    # 2. V√©rification Technique (ATR)\n    df = get_price_data(SYMBOL, mt5.TIMEFRAME_M5, 50)\n    if df.empty: return False, \"Donn√©es indisponibles\"",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "detect_chart_patterns",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def detect_chart_patterns(df):\n    \"\"\"D√©tecte les figures chartistes redoutables (W, M, ETE)\"\"\"\n    if len(df) < 20: return None\n    last_prices = df['close'].values\n    highs = df['high'].values\n    lows = df['low'].values\n    # 1. Double Bas (W) / Double Sommet (M)\n    # On compare les derniers creux/sommets locaux\n    if lows[-1] > lows[-5] and abs(lows[-5] - lows[-10]) < (lows[-1] * 0.001):\n        return \"DOUBLE_BOTTOM\"",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "analyze_amd_cycle",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def analyze_amd_cycle(symbol, timeframe):\n    \"\"\"Logique Accumulation - Manipulation - Distribution\"\"\"\n    df = get_price_data(symbol, timeframe, 100)\n    if df.empty: return None\n    # 1. Accumulation : Range √©troit et volume faible\n    std_dev = df['close'].tail(20).std()\n    avg_std = df['close'].rolling(50).std().mean()\n    is_accumulating = std_dev < (avg_std * 0.7)\n    if is_accumulating:\n        # On d√©finit les bornes du range",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "get_best_timeframe_amd",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def get_best_timeframe_amd():\n    \"\"\"Cherche l'accumulation sur les TF les plus hautes en priorit√©\"\"\"\n    timeframes = [\n        (mt5.TIMEFRAME_H4, \"H4\"),\n        (mt5.TIMEFRAME_H1, \"H1\"),\n        (mt5.TIMEFRAME_M30, \"M30\")\n    ]\n    for tf, name in timeframes:\n        amd_data = analyze_amd_cycle(SYMBOL, tf)\n        if amd_data:",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "MAX_ALLOWED_SPREAD",
        "kind": 5,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "MAX_ALLOWED_SPREAD = 0.60\ndef get_price_data(symbol, timeframe, n_bars=300):\n    \"\"\"R√©cup√®re les donn√©es OHLCV\"\"\"\n    rates = mt5.copy_rates_from_pos(symbol, timeframe, 0, n_bars)\n    if rates is None or len(rates) == 0:\n        return pd.DataFrame()\n    df = pd.DataFrame(rates)\n    df['time'] = pd.to_datetime(df['time'], unit='s')\n    return df\ndef get_zigzag(df, depth=10, zz_column_name='zz'):",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "setup_logging",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def setup_logging():\n    \"\"\"Configure logging : fichier quotidien + console\"\"\"\n    if not os.path.exists(\"logs\"):\n        os.makedirs(\"logs\")\n    log_filename = f\"logs/bot_{datetime.now().strftime('%Y%m%d')}.log\"\n    logging.basicConfig(\n        level=logging.INFO,\n        format=\"%(asctime)s | %(levelname)s | %(message)s\",\n        handlers=[\n            logging.StreamHandler(sys.stdout),",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "send_telegram_alert",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def send_telegram_alert(message: str, force=True):\n    \"\"\"Envoie alerte Telegram seulement pour √©v√©nements cl√©s (launch, close bot, open/close position)\"\"\"\n    if not TELEGRAM_TOKEN or not TELEGRAM_CHAT_ID:\n        logging.warning(\"Config Telegram manquante\")\n        return\n    try:\n        bot = Bot(token=TELEGRAM_TOKEN)\n        asyncio.run(bot.send_message(chat_id=TELEGRAM_CHAT_ID, text=message.strip(), parse_mode=\"HTML\"))\n    except Exception as e:\n        logging.error(f\"√âchec Telegram : {e}\")",
        "detail": "utils",
        "documentation": {}
    }
]