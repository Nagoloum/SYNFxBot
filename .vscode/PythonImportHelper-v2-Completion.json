[
    {
        "label": "streamlit",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "streamlit",
        "description": "streamlit",
        "detail": "streamlit",
        "documentation": {}
    },
    {
        "label": "st_autorefresh",
        "importPath": "streamlit_autorefresh",
        "description": "streamlit_autorefresh",
        "isExtraImport": true,
        "detail": "streamlit_autorefresh",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "plotly.express",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "plotly.express",
        "description": "plotly.express",
        "detail": "plotly.express",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "MongoClient",
        "importPath": "pymongo",
        "description": "pymongo",
        "isExtraImport": true,
        "detail": "pymongo",
        "documentation": {}
    },
    {
        "label": "MongoClient",
        "importPath": "pymongo",
        "description": "pymongo",
        "isExtraImport": true,
        "detail": "pymongo",
        "documentation": {}
    },
    {
        "label": "MetaTrader5",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "MetaTrader5",
        "description": "MetaTrader5",
        "detail": "MetaTrader5",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "ACCOUNT_NUMBER",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "PASSWORD",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "SERVER",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "MT5_TERMINAL_PATH",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "MONGODB_URI",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "DB_NAME",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "COLLECTION_NAME",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "SYMBOL",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "SYMBOL",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "MAGIC_NUMBER",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "TELEGRAM_TOKEN",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "TELEGRAM_CHAT_ID",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "send_telegram_alert",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "setup_logging",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "send_telegram_alert",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "init_db",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "save_open",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "collection",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "connect_to_mt5",
        "importPath": "connexion",
        "description": "connexion",
        "isExtraImport": true,
        "detail": "connexion",
        "documentation": {}
    },
    {
        "label": "disconnect",
        "importPath": "connexion",
        "description": "connexion",
        "isExtraImport": true,
        "detail": "connexion",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "get_smart_signal",
        "importPath": "strategy",
        "description": "strategy",
        "isExtraImport": true,
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "monitor_active_trade",
        "importPath": "strategy",
        "description": "strategy",
        "isExtraImport": true,
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "get_smart_signal",
        "importPath": "strategy",
        "description": "strategy",
        "isExtraImport": true,
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "is_volatility_good",
        "importPath": "strategy",
        "description": "strategy",
        "isExtraImport": true,
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "open_trade",
        "importPath": "strategy",
        "description": "strategy",
        "isExtraImport": true,
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "pandas_ta",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas_ta",
        "description": "pandas_ta",
        "detail": "pandas_ta",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "asyncio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "asyncio",
        "description": "asyncio",
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "Bot",
        "importPath": "telegram",
        "description": "telegram",
        "isExtraImport": true,
        "detail": "telegram",
        "documentation": {}
    },
    {
        "label": "get_db_collection",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def get_db_collection():\n    uri = os.getenv(\"MONGODB_URI\")\n    client = MongoClient(uri)\n    db = client[\"SYNTHBOT\"]\n    return db[\"trades_v100\"]\ncollection = get_db_collection()\n# --- CHARGEMENT DES DONNÃ‰ES ---\n@st.cache_data(ttl=10)\ndef load_trades():\n    trades = list(collection.find().sort(\"open_time\", -1))",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "load_trades",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def load_trades():\n    trades = list(collection.find().sort(\"open_time\", -1))\n    if not trades:\n        return pd.DataFrame()\n    df = pd.DataFrame(trades)\n    # Conversion forcÃ©e en datetime\n    if \"open_time\" in df.columns:\n        df[\"open_time\"] = pd.to_datetime(df[\"open_time\"])\n    if \"close_time\" in df.columns:\n        df[\"close_time\"] = pd.to_datetime(df[\"close_time\"])",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "style_profit",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def style_profit(val):\n    return f'color: {\"red\" if val < 0 else \"green\"}'\nst.dataframe(\n    df[available].style.applymap(style_profit, subset=['profit']),\n    use_container_width=True\n)",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "collection",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "collection = get_db_collection()\n# --- CHARGEMENT DES DONNÃ‰ES ---\n@st.cache_data(ttl=10)\ndef load_trades():\n    trades = list(collection.find().sort(\"open_time\", -1))\n    if not trades:\n        return pd.DataFrame()\n    df = pd.DataFrame(trades)\n    # Conversion forcÃ©e en datetime\n    if \"open_time\" in df.columns:",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "df_raw",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "df_raw = load_trades()\n# --- BARRE LATÃ‰RALE (FILTRES) ---\nwith st.sidebar:\n    st.title(\"ðŸ“ˆ Volatility 100 Index\")\n    st.title(\"âš™ï¸ Filtres Statistiques\")\n    # 1. Filtre de PÃ©riode\n    periode = st.selectbox(\n        \"Choisir la pÃ©riode\",\n        [\"Tout\", \"Aujourd'hui\", \"Cette Semaine\", \"Ce Mois\", \"Cette AnnÃ©e\"]\n    )",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "df = df_raw.copy()\nif not df.empty:\n    now = datetime.now()\n    if periode == \"Aujourd'hui\":\n        # Filtrer depuis minuit (00:00:00)\n        start_date = now.replace(hour=0, minute=0, second=0, microsecond=0)\n        df = df[df[\"open_time\"] >= start_date]\n    elif periode == \"Cette Semaine\":\n        # Filtrer les 7 derniers jours\n        start_date = now - timedelta(days=7)",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "total_trades",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "total_trades = len(df)\nwins = len(df[df[\"profit\"] > 0])\nwin_rate = (wins / total_trades * 100) if total_trades > 0 else 0\nnet_profit = df[\"profit\"].sum()\navg_profit = df[\"profit\"].mean() if total_trades > 0 else 0\ncol1.metric(\"Trades\", total_trades)\ncol2.metric(\"Win Rate\", f\"{win_rate:.1f}%\")\ncol3.metric(\"Profit Net\", f\"{net_profit:.2f} USD\")\ncol4.metric(\"Moyenne/Trade\", f\"{avg_profit:+.2f} USD\")\n# --- GRAPHIQUE ---",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "wins",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "wins = len(df[df[\"profit\"] > 0])\nwin_rate = (wins / total_trades * 100) if total_trades > 0 else 0\nnet_profit = df[\"profit\"].sum()\navg_profit = df[\"profit\"].mean() if total_trades > 0 else 0\ncol1.metric(\"Trades\", total_trades)\ncol2.metric(\"Win Rate\", f\"{win_rate:.1f}%\")\ncol3.metric(\"Profit Net\", f\"{net_profit:.2f} USD\")\ncol4.metric(\"Moyenne/Trade\", f\"{avg_profit:+.2f} USD\")\n# --- GRAPHIQUE ---\nst.subheader(\"Ã‰volution du Profit\")",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "win_rate",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "win_rate = (wins / total_trades * 100) if total_trades > 0 else 0\nnet_profit = df[\"profit\"].sum()\navg_profit = df[\"profit\"].mean() if total_trades > 0 else 0\ncol1.metric(\"Trades\", total_trades)\ncol2.metric(\"Win Rate\", f\"{win_rate:.1f}%\")\ncol3.metric(\"Profit Net\", f\"{net_profit:.2f} USD\")\ncol4.metric(\"Moyenne/Trade\", f\"{avg_profit:+.2f} USD\")\n# --- GRAPHIQUE ---\nst.subheader(\"Ã‰volution du Profit\")\ndf_sorted = df.sort_values(\"open_time\")",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "net_profit",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "net_profit = df[\"profit\"].sum()\navg_profit = df[\"profit\"].mean() if total_trades > 0 else 0\ncol1.metric(\"Trades\", total_trades)\ncol2.metric(\"Win Rate\", f\"{win_rate:.1f}%\")\ncol3.metric(\"Profit Net\", f\"{net_profit:.2f} USD\")\ncol4.metric(\"Moyenne/Trade\", f\"{avg_profit:+.2f} USD\")\n# --- GRAPHIQUE ---\nst.subheader(\"Ã‰volution du Profit\")\ndf_sorted = df.sort_values(\"open_time\")\ndf_sorted[\"cum_profit\"] = df_sorted[\"profit\"].cumsum()",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "avg_profit",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "avg_profit = df[\"profit\"].mean() if total_trades > 0 else 0\ncol1.metric(\"Trades\", total_trades)\ncol2.metric(\"Win Rate\", f\"{win_rate:.1f}%\")\ncol3.metric(\"Profit Net\", f\"{net_profit:.2f} USD\")\ncol4.metric(\"Moyenne/Trade\", f\"{avg_profit:+.2f} USD\")\n# --- GRAPHIQUE ---\nst.subheader(\"Ã‰volution du Profit\")\ndf_sorted = df.sort_values(\"open_time\")\ndf_sorted[\"cum_profit\"] = df_sorted[\"profit\"].cumsum()\nfig = px.area(df_sorted, x=\"open_time\", y=\"cum_profit\", ",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "df_sorted",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "df_sorted = df.sort_values(\"open_time\")\ndf_sorted[\"cum_profit\"] = df_sorted[\"profit\"].cumsum()\nfig = px.area(df_sorted, x=\"open_time\", y=\"cum_profit\", \n              labels={\"cum_profit\": \"Profit (USD)\", \"open_time\": \"Date\"},\n              color_discrete_sequence=[\"#00CC96\"])\nst.plotly_chart(fig, use_container_width=True)\n# --- TABLEAU ---\nst.subheader(\"DÃ©tails des Positions\")\ndisplay_cols = [\"ticket\", \"type\", \"open_price\", \"close_price\", \"profit\", \"status\", \"open_time\"]\navailable = [c for c in display_cols if c in df.columns]",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "df_sorted[\"cum_profit\"]",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "df_sorted[\"cum_profit\"] = df_sorted[\"profit\"].cumsum()\nfig = px.area(df_sorted, x=\"open_time\", y=\"cum_profit\", \n              labels={\"cum_profit\": \"Profit (USD)\", \"open_time\": \"Date\"},\n              color_discrete_sequence=[\"#00CC96\"])\nst.plotly_chart(fig, use_container_width=True)\n# --- TABLEAU ---\nst.subheader(\"DÃ©tails des Positions\")\ndisplay_cols = [\"ticket\", \"type\", \"open_price\", \"close_price\", \"profit\", \"status\", \"open_time\"]\navailable = [c for c in display_cols if c in df.columns]\ndef style_profit(val):",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "fig",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "fig = px.area(df_sorted, x=\"open_time\", y=\"cum_profit\", \n              labels={\"cum_profit\": \"Profit (USD)\", \"open_time\": \"Date\"},\n              color_discrete_sequence=[\"#00CC96\"])\nst.plotly_chart(fig, use_container_width=True)\n# --- TABLEAU ---\nst.subheader(\"DÃ©tails des Positions\")\ndisplay_cols = [\"ticket\", \"type\", \"open_price\", \"close_price\", \"profit\", \"status\", \"open_time\"]\navailable = [c for c in display_cols if c in df.columns]\ndef style_profit(val):\n    return f'color: {\"red\" if val < 0 else \"green\"}'",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "display_cols",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "display_cols = [\"ticket\", \"type\", \"open_price\", \"close_price\", \"profit\", \"status\", \"open_time\"]\navailable = [c for c in display_cols if c in df.columns]\ndef style_profit(val):\n    return f'color: {\"red\" if val < 0 else \"green\"}'\nst.dataframe(\n    df[available].style.applymap(style_profit, subset=['profit']),\n    use_container_width=True\n)",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "available",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "available = [c for c in display_cols if c in df.columns]\ndef style_profit(val):\n    return f'color: {\"red\" if val < 0 else \"green\"}'\nst.dataframe(\n    df[available].style.applymap(style_profit, subset=['profit']),\n    use_container_width=True\n)",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "ACCOUNT_NUMBER",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "ACCOUNT_NUMBER = int(os.getenv(\"ACCOUNT_NUMBER\", \"0\"))\nPASSWORD = os.getenv(\"PASSWORD\", \"\")\nSERVER = os.getenv(\"SERVER\", \"\")\nMT5_TERMINAL_PATH = r\"C:\\Program Files\\MetaTrader 5\\terminal64.exe\"\n# Uniquement V100\nSYMBOL = [\"Volatility 25 Index\", \"Volatility 50 Index\", \"Volatility 75 Index\", \"Volatility 100 Index\"]\nLOT_SIZE = 1.0  # Volume fixe pour le test\nMAGIC_NUMBER = 123456\n# Telegram\nTELEGRAM_TOKEN = os.getenv(\"TELEGRAM_TOKEN\", \"\")",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "PASSWORD",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "PASSWORD = os.getenv(\"PASSWORD\", \"\")\nSERVER = os.getenv(\"SERVER\", \"\")\nMT5_TERMINAL_PATH = r\"C:\\Program Files\\MetaTrader 5\\terminal64.exe\"\n# Uniquement V100\nSYMBOL = [\"Volatility 25 Index\", \"Volatility 50 Index\", \"Volatility 75 Index\", \"Volatility 100 Index\"]\nLOT_SIZE = 1.0  # Volume fixe pour le test\nMAGIC_NUMBER = 123456\n# Telegram\nTELEGRAM_TOKEN = os.getenv(\"TELEGRAM_TOKEN\", \"\")\nTELEGRAM_CHAT_ID = os.getenv(\"TELEGRAM_CHAT_ID\", \"\")",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "SERVER",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "SERVER = os.getenv(\"SERVER\", \"\")\nMT5_TERMINAL_PATH = r\"C:\\Program Files\\MetaTrader 5\\terminal64.exe\"\n# Uniquement V100\nSYMBOL = [\"Volatility 25 Index\", \"Volatility 50 Index\", \"Volatility 75 Index\", \"Volatility 100 Index\"]\nLOT_SIZE = 1.0  # Volume fixe pour le test\nMAGIC_NUMBER = 123456\n# Telegram\nTELEGRAM_TOKEN = os.getenv(\"TELEGRAM_TOKEN\", \"\")\nTELEGRAM_CHAT_ID = os.getenv(\"TELEGRAM_CHAT_ID\", \"\")\n# MongoDB",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "MT5_TERMINAL_PATH",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "MT5_TERMINAL_PATH = r\"C:\\Program Files\\MetaTrader 5\\terminal64.exe\"\n# Uniquement V100\nSYMBOL = [\"Volatility 25 Index\", \"Volatility 50 Index\", \"Volatility 75 Index\", \"Volatility 100 Index\"]\nLOT_SIZE = 1.0  # Volume fixe pour le test\nMAGIC_NUMBER = 123456\n# Telegram\nTELEGRAM_TOKEN = os.getenv(\"TELEGRAM_TOKEN\", \"\")\nTELEGRAM_CHAT_ID = os.getenv(\"TELEGRAM_CHAT_ID\", \"\")\n# MongoDB\nMONGODB_URI = os.getenv(\"MONGODB_URI\", \"\")",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "SYMBOL",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "SYMBOL = [\"Volatility 25 Index\", \"Volatility 50 Index\", \"Volatility 75 Index\", \"Volatility 100 Index\"]\nLOT_SIZE = 1.0  # Volume fixe pour le test\nMAGIC_NUMBER = 123456\n# Telegram\nTELEGRAM_TOKEN = os.getenv(\"TELEGRAM_TOKEN\", \"\")\nTELEGRAM_CHAT_ID = os.getenv(\"TELEGRAM_CHAT_ID\", \"\")\n# MongoDB\nMONGODB_URI = os.getenv(\"MONGODB_URI\", \"\")\nDB_NAME = os.getenv(\"MONGODB_DB\", \"trading_bot_V100\")\nCOLLECTION_NAME = \"trades_v100\"",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "LOT_SIZE",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "LOT_SIZE = 1.0  # Volume fixe pour le test\nMAGIC_NUMBER = 123456\n# Telegram\nTELEGRAM_TOKEN = os.getenv(\"TELEGRAM_TOKEN\", \"\")\nTELEGRAM_CHAT_ID = os.getenv(\"TELEGRAM_CHAT_ID\", \"\")\n# MongoDB\nMONGODB_URI = os.getenv(\"MONGODB_URI\", \"\")\nDB_NAME = os.getenv(\"MONGODB_DB\", \"trading_bot_V100\")\nCOLLECTION_NAME = \"trades_v100\"\nSTART_HOUR = 8 ",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "MAGIC_NUMBER",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "MAGIC_NUMBER = 123456\n# Telegram\nTELEGRAM_TOKEN = os.getenv(\"TELEGRAM_TOKEN\", \"\")\nTELEGRAM_CHAT_ID = os.getenv(\"TELEGRAM_CHAT_ID\", \"\")\n# MongoDB\nMONGODB_URI = os.getenv(\"MONGODB_URI\", \"\")\nDB_NAME = os.getenv(\"MONGODB_DB\", \"trading_bot_V100\")\nCOLLECTION_NAME = \"trades_v100\"\nSTART_HOUR = 8 \nEND_HOUR = 23",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "TELEGRAM_TOKEN",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "TELEGRAM_TOKEN = os.getenv(\"TELEGRAM_TOKEN\", \"\")\nTELEGRAM_CHAT_ID = os.getenv(\"TELEGRAM_CHAT_ID\", \"\")\n# MongoDB\nMONGODB_URI = os.getenv(\"MONGODB_URI\", \"\")\nDB_NAME = os.getenv(\"MONGODB_DB\", \"trading_bot_V100\")\nCOLLECTION_NAME = \"trades_v100\"\nSTART_HOUR = 8 \nEND_HOUR = 23",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "TELEGRAM_CHAT_ID",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "TELEGRAM_CHAT_ID = os.getenv(\"TELEGRAM_CHAT_ID\", \"\")\n# MongoDB\nMONGODB_URI = os.getenv(\"MONGODB_URI\", \"\")\nDB_NAME = os.getenv(\"MONGODB_DB\", \"trading_bot_V100\")\nCOLLECTION_NAME = \"trades_v100\"\nSTART_HOUR = 8 \nEND_HOUR = 23",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "MONGODB_URI",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "MONGODB_URI = os.getenv(\"MONGODB_URI\", \"\")\nDB_NAME = os.getenv(\"MONGODB_DB\", \"trading_bot_V100\")\nCOLLECTION_NAME = \"trades_v100\"\nSTART_HOUR = 8 \nEND_HOUR = 23",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "DB_NAME",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "DB_NAME = os.getenv(\"MONGODB_DB\", \"trading_bot_V100\")\nCOLLECTION_NAME = \"trades_v100\"\nSTART_HOUR = 8 \nEND_HOUR = 23",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "COLLECTION_NAME",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "COLLECTION_NAME = \"trades_v100\"\nSTART_HOUR = 8 \nEND_HOUR = 23",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "START_HOUR",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "START_HOUR = 8 \nEND_HOUR = 23",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "END_HOUR",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "END_HOUR = 23",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "connect_to_mt5",
        "kind": 2,
        "importPath": "connexion",
        "description": "connexion",
        "peekOfCode": "def connect_to_mt5(max_retries=3, delay=5):\n    \"\"\"Connexion MT5 avec retries\"\"\"\n    terminal_path = MT5_TERMINAL_PATH\n    for attempt in range(1, max_retries + 1):\n        try:\n            if mt5.terminal_info():\n                mt5.shutdown()\n                time.sleep(1)\n            # logging.info(f\"Tentative connexion {attempt}/{max_retries}\")\n            if not mt5.initialize(path=terminal_path):",
        "detail": "connexion",
        "documentation": {}
    },
    {
        "label": "disconnect",
        "kind": 2,
        "importPath": "connexion",
        "description": "connexion",
        "peekOfCode": "def disconnect():\n    \"\"\"DÃ©connexion\"\"\"\n    try:\n        if mt5.terminal_info():\n            mt5.shutdown()\n        logging.info(\"Bot arrÃªtÃ©\")\n        send_telegram_alert(\"ðŸ›‘ Bot arrÃªtÃ©\", force=True)  # Alert close\n    except Exception as e:\n        logging.error(f\"Erreur dÃ©connexion : {e}\")",
        "detail": "connexion",
        "documentation": {}
    },
    {
        "label": "init_db",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def init_db():\n    global collection\n    try:\n        client = MongoClient(MONGODB_URI, serverSelectionTimeoutMS=5000)\n        collection = client[DB_NAME][COLLECTION_NAME]\n        # logging.info(\"ðŸ’¾ MongoDB : ConnectÃ©\")\n    except Exception as e:\n        logging.error(f\"âŒ Erreur MongoDB : {e}\")\n# database.py\ndef save_open(ticket, type_trade, price): # Ajoute type_trade ici",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "save_open",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def save_open(ticket, type_trade, price): # Ajoute type_trade ici\n    if collection is not None:\n        try:\n            collection.insert_one({\n                \"ticket\": ticket, \n                \"type\": type_trade, # Utilise l'argument reÃ§u\n                \"open_price\": float(price),\n                \"open_time\": datetime.utcnow(), \n                \"status\": \"OPEN\"\n            })",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "save_close",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def save_close(ticket, profit, price):\n    if collection is not None:\n        collection.update_one(\n            {\"ticket\": ticket},\n            {\"$set\": {\"close_price\": price, \"close_time\": datetime.utcnow(), \"profit\": profit, \"status\": \"CLOSED\"}}\n        )",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "collection",
        "kind": 5,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "collection = None\ndef init_db():\n    global collection\n    try:\n        client = MongoClient(MONGODB_URI, serverSelectionTimeoutMS=5000)\n        collection = client[DB_NAME][COLLECTION_NAME]\n        # logging.info(\"ðŸ’¾ MongoDB : ConnectÃ©\")\n    except Exception as e:\n        logging.error(f\"âŒ Erreur MongoDB : {e}\")\n# database.py",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "run_bot_for_symbol",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def run_bot_for_symbol(symbol):\n    \"\"\"Boucle d'analyse indÃ©pendante pour chaque indice\"\"\"\n    logging.info(f\"ðŸš€ Analyse du marchÃ© {symbol}\")\n    while True:\n        try:\n            if not mt5.terminal_info().connected:\n                time.sleep(5)\n                continue\n            # VÃ©rification de la volatilitÃ© propre Ã  l'indice\n            vol_ok, _ = is_volatility_good(symbol)",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "get_price_data",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def get_price_data(symbol, timeframe, n_bars=400):\n    \"\"\"RÃ©cupÃ¨re les donnÃ©es OHLCV pour un symbole spÃ©cifique\"\"\"\n    rates = mt5.copy_rates_from_pos(symbol, timeframe, 0, n_bars)\n    if rates is None or len(rates) == 0:\n        logging.warning(f\"DonnÃ©es indisponibles pour {symbol} en TF {timeframe}\")\n        return pd.DataFrame()\n    df = pd.DataFrame(rates)\n    df['time'] = pd.to_datetime(df['time'], unit='s')\n    return df\ndef get_dynamic_lot(symbol, risk_percent=0.01):",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "get_dynamic_lot",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def get_dynamic_lot(symbol, risk_percent=0.01):\n    \"\"\"Calcule le lot minimal ou basÃ© sur le risque pour chaque indice\"\"\"\n    symbol_info = mt5.symbol_info(symbol)\n    if symbol_info is None:\n        return 0.1\n    # Pour les indices synthÃ©tiques, on commence souvent par le lot minimal autorisÃ©\n    # car la volatilitÃ© est dÃ©jÃ  intrinsÃ¨quement Ã©levÃ©e.\n    min_lot = symbol_info.volume_min\n    return min_lot\ndef get_zigzag(df, depth=10):",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "get_zigzag",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def get_zigzag(df, depth=10):\n    \"\"\"Calcule les points hauts et bas (ZigZag) avec sÃ©curitÃ©\"\"\"\n    try:\n        zz_df = ta.zigzag(df['high'], df['low'], depth=depth)\n        zigzag_col = None\n        for col in zz_df.columns:\n            if col.startswith('ZIGZAGs'):\n                zigzag_col = col\n                break\n        if zigzag_col is None:",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "detect_advanced_patterns",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def detect_advanced_patterns(symbol, df):\n    \"\"\"DÃ©tection W / M via ZigZag adaptÃ©e au symbole\"\"\"\n    peaks = get_zigzag(df, depth=6)\n    if len(peaks) < 5:\n        return None\n    p = peaks['zz'].values\n    # Seuil de tolÃ©rance adaptÃ© Ã  la volatilitÃ© de l'indice\n    tolerance = p[-1] * 0.002 \n    # Double Bottom (W)\n    if p[-1] > p[-2] and abs(p[-2] - p[-4]) < tolerance and p[-3] > p[-2]:",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "get_market_trend_h4",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def get_market_trend_h4(symbol):\n    \"\"\"Filtre de tendance haute timeframe (H4) pour un symbole\"\"\"\n    df = get_price_data(symbol, mt5.TIMEFRAME_H4, 200)\n    if df.empty: return \"NEUTRAL\"\n    df['ema_50'] = ta.ema(df['close'], length=EMA_PERIOD_H4)\n    if df['ema_50'].isna().all(): return \"NEUTRAL\"\n    trend = \"UP\" if df['close'].iloc[-1] > df['ema_50'].iloc[-1] else \"DOWN\"\n    return trend\ndef analyze_amd_priority(symbol):\n    \"\"\"Logique Accumulation -> Manipulation sur H1 avec gestion d'erreur robuste\"\"\"",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "analyze_amd_priority",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def analyze_amd_priority(symbol):\n    \"\"\"Logique Accumulation -> Manipulation sur H1 avec gestion d'erreur robuste\"\"\"\n    # Augmenter le nombre de bougies pour Ãªtre sÃ»r d'avoir assez de data\n    df = get_price_data(symbol, mt5.TIMEFRAME_H1, 200) \n    if df.empty or len(df) < 50: \n        return None\n    # Calcul des Bandes de Bollinger\n    bb = ta.bbands(df['close'], length=20, std=2)\n    # Correction : On cherche les colonnes dynamiquement pour Ã©viter l'erreur de nom\n    if bb is None or bb.empty:",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "analyze_market_structure",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def analyze_market_structure(df):\n    \"\"\"Ã‰tat du marchÃ© : tendance ou range (M30 ou H1 recommandÃ©)\"\"\"\n    logging.info(f\"[MARKET STRUCTURE] Analyse sur {len(df)} bougies\")\n    if len(df) < 50:\n        logging.warning(\"[MARKET STRUCTURE] DonnÃ©es insuffisantes pour analyse.\")\n        return \"INSUFFISANT\", 0, 0\n    adx = ta.adx(df['high'], df['low'], df['close'], length=14)\n    current_adx = adx['ADX_14'].iloc[-1]\n    logging.info(f\"[MARKET STRUCTURE] ADX actuel : {current_adx:.2f}\")\n    resistance = df['high'].rolling(window=20).max().iloc[-1]",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "check_fvg",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def check_fvg(df, lookback=5, min_gap=0.50):\n    logging.info(\"[FVG] VÃ©rification Fair Value Gap\")\n    \"\"\"Fair Value Gap simple sur les 3 derniÃ¨res bougies\"\"\"\n    if len(df) < 3:\n        logging.warning(\"[FVG] DonnÃ©es insuffisantes pour analyse FVG. Pas assezde de bougies.\")\n        return False, None\n    if df['high'].iloc[-3] < df['low'].iloc[-1]:\n        logging.info(\"[FVG] Fair Value Gap BULLISH dÃ©tectÃ©.\")\n        logging.info(f\"[FVG] Gap dÃ©tectÃ© â†’ zone : {df['high'].iloc[-3]:.5f} - {df['low'].iloc[-1]:.5f}\")\n        return True, \"BULLISH\"",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "get_smart_signal",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def get_smart_signal(symbol):\n    \"\"\"Analyse complÃ¨te pour un symbole donnÃ©\"\"\"\n    tick = mt5.symbol_info_tick(symbol)\n    if not tick: return None\n    # 1. PrioritÃ© AMD\n    amd = analyze_amd_priority(symbol)\n    if amd: return amd\n    # 2. Figures Chartistes H1\n    df_h1 = get_price_data(symbol, mt5.TIMEFRAME_H1, 200)\n    pattern = detect_advanced_patterns(symbol, df_h1)",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "find_swings",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def find_swings(df):\n    \"\"\"Identifie les fractales pour Fibonacci\"\"\"\n    df['high_swing'] = df['high'][(df['high'] == df['high'].rolling(11, center=True).max())]\n    df['low_swing'] = df['low'][(df['low'] == df['low'].rolling(11, center=True).min())]\n    try:\n        last_low = df['low_swing'].dropna().iloc[-1]\n        last_high = df['high_swing'].dropna().iloc[-1]\n        return last_low, last_high\n    except IndexError:\n        return None, None",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "update_db_profit",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def update_db_profit(ticket, profit, close_price, status=\"CLOSED\"):\n    \"\"\"Met Ã  jour MongoDB en ajoutant le profit (gÃ¨re partiels et BE)\"\"\"\n    collection.update_one(\n        {\"ticket\": ticket},\n        {\"$inc\": {\"profit\": float(profit)}, \n         \"$set\": {\"close_price\": float(close_price), \"status\": status, \"close_time\": datetime.utcnow()}}\n    )\ndef detect_chart_patterns(df):\n    \"\"\"DÃ©tecte les figures chartistes redoutables (W, M, ETE)\"\"\"\n    if len(df) < 20: return None",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "detect_chart_patterns",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def detect_chart_patterns(df):\n    \"\"\"DÃ©tecte les figures chartistes redoutables (W, M, ETE)\"\"\"\n    if len(df) < 20: return None\n    last_prices = df['close'].values\n    highs = df['high'].values\n    lows = df['low'].values\n    # 1. Double Bas (W) / Double Sommet (M)\n    # On compare les derniers creux/sommets locaux\n    if lows[-1] > lows[-5] and abs(lows[-5] - lows[-10]) < (lows[-1] * 0.001):\n        return \"DOUBLE_BOTTOM\"",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "analyze_amd_cycle",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def analyze_amd_cycle(symbol, timeframe):\n    \"\"\"Logique Accumulation - Manipulation - Distribution\"\"\"\n    df = get_price_data(symbol, timeframe, 400)\n    if df.empty: return None\n    # 1. Accumulation : Range Ã©troit et volume faible\n    std_dev = df['close'].tail(20).std()\n    avg_std = df['close'].rolling(50).std().mean()\n    is_accumulating = std_dev < (avg_std * 0.7)\n    if is_accumulating:\n        # On dÃ©finit les bornes du range",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "get_best_timeframe_amd",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def get_best_timeframe_amd():\n    \"\"\"Cherche l'accumulation sur les TF les plus hautes en prioritÃ©\"\"\"\n    timeframes = [\n        (mt5.TIMEFRAME_H4, \"H4\"),\n        (mt5.TIMEFRAME_H1, \"H1\"),\n    ]\n    for tf, name in timeframes:\n        amd_data = analyze_amd_cycle(SYMBOL, tf)\n        if amd_data:\n            print(f\"ðŸ’Ž Accumulation majeure dÃ©tectÃ©e sur {name}. PrioritÃ© AMD activÃ©e.\")",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "move_sl_to_be",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def move_sl_to_be(symbol, ticket):\n    \"\"\"SÃ©curise la position au prix d'entrÃ©e (Break-Even)\"\"\"\n    pos = mt5.positions_get(ticket=ticket)\n    if not pos: return False\n    p = pos[0]\n    # Si le SL est dÃ©jÃ  au prix d'entrÃ©e, on ne fait rien\n    if p.sl == p.price_open: return True\n    request = {\n        \"action\": mt5.TRADE_ACTION_SLTP,\n        \"symbol\": symbol,",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "monitor_active_trade",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def monitor_active_trade(symbol, ticket, lot, signal_data):\n    \"\"\"Surveille une position spÃ©cifique et gÃ¨re le cycle de vie complet\"\"\"\n    half_done = False\n    logging.info(f\"ðŸ‘€ [{symbol}] Surveillance active du ticket {ticket}...\")\n    while True:\n        positions = mt5.positions_get(ticket=ticket)\n        # SI LA POSITION N'EXISTE PLUS (ClÃ´ture Totale)\n        if not positions:\n            time.sleep(1) # Attendre que l'historique se mette Ã  jour\n            history = mt5.history_deals_get(ticket=ticket)",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "monitor_active_trade",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def monitor_active_trade(symbol, ticket, lot, signal_data):\n    \"\"\"Surveille une position spÃ©cifique sans bloquer les autres analyses\"\"\"\n    half_done = False\n    logging.info(f\"ðŸ‘€ [{symbol}] Surveillance active du ticket {ticket}...\")\n    while True:\n        positions = mt5.positions_get(ticket=ticket)\n        if not positions:\n            handle_trade_closure(symbol, ticket, lot, \"SL/TP SERVEUR\")\n            break\n        pos = positions[0]",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "close_partial",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def close_partial(symbol, ticket, vol):\n    \"\"\"ClÃ´ture partielle sÃ©curisÃ©e avec reporting de profit\"\"\"\n    pos = mt5.positions_get(ticket=ticket)\n    if not pos: return False\n    tick = mt5.symbol_info_tick(symbol)\n    request = {\n        \"action\": mt5.TRADE_ACTION_DEAL,\n        \"symbol\": symbol,\n        \"volume\": float(vol),\n        \"type\": mt5.ORDER_TYPE_SELL if pos[0].type == mt5.ORDER_TYPE_BUY else mt5.ORDER_TYPE_BUY,",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "is_volatility_good",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def is_volatility_good(symbol):\n    \"\"\"VÃ©rifie si l'indice est assez 'excitÃ©' pour Ãªtre tradÃ©\"\"\"\n    df = get_price_data(symbol, mt5.TIMEFRAME_H1, 50)\n    if df.empty: return False, \"Pas de data\"\n    atr = ta.atr(df['high'], df['low'], df['close'], length=14)\n    if atr is None or len(atr) < 1: return False, \"ATR Error\"\n    current_atr = atr.iloc[-1]\n    avg_atr = atr.mean()\n    if current_atr < (avg_atr * 0.7):\n        return False, f\"{symbol} trop calme\"",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "handle_trade_closure",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def handle_trade_closure(symbol, ticket, lot, reason):\n    \"\"\"GÃ¨re la fin d'un trade et log le rÃ©sultat\"\"\"\n    logging.info(f\"ðŸ [{symbol}] Position {ticket} fermÃ©e ({reason})\")\n    send_telegram_alert(f\"ðŸ [{symbol}] Trade fermÃ© : {reason}\")\ndef open_trade(symbol, signal):\n    \"\"\"ExÃ©cution d'ordre universelle pour Indices SynthÃ©tiques avec rapport complet\"\"\"\n    tick = mt5.symbol_info_tick(symbol)\n    if not tick:\n        logging.error(f\"Impossible de rÃ©cupÃ©rer le tick pour {symbol}\")\n        return None, 0",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "open_trade",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def open_trade(symbol, signal):\n    \"\"\"ExÃ©cution d'ordre universelle pour Indices SynthÃ©tiques avec rapport complet\"\"\"\n    tick = mt5.symbol_info_tick(symbol)\n    if not tick:\n        logging.error(f\"Impossible de rÃ©cupÃ©rer le tick pour {symbol}\")\n        return None, 0\n    lot = get_dynamic_lot(symbol)\n    price = tick.ask if signal['type'] == \"BUY\" else tick.bid\n    request = {\n        \"action\": mt5.TRADE_ACTION_DEAL,",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "MAX_ALLOWED_SPREAD",
        "kind": 5,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "MAX_ALLOWED_SPREAD = 0.60\ndef get_price_data(symbol, timeframe, n_bars=400):\n    \"\"\"RÃ©cupÃ¨re les donnÃ©es OHLCV pour un symbole spÃ©cifique\"\"\"\n    rates = mt5.copy_rates_from_pos(symbol, timeframe, 0, n_bars)\n    if rates is None or len(rates) == 0:\n        logging.warning(f\"DonnÃ©es indisponibles pour {symbol} en TF {timeframe}\")\n        return pd.DataFrame()\n    df = pd.DataFrame(rates)\n    df['time'] = pd.to_datetime(df['time'], unit='s')\n    return df",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "setup_logging",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def setup_logging(\n    level=logging.INFO,\n    console_level=logging.INFO,      # niveau pour la console (peut Ãªtre plus verbeux)\n    file_level=logging.DEBUG,        # niveau pour le fichier (plus dÃ©taillÃ©)\n    log_dir=\"logs\"\n):\n    \"\"\"\n    Configure le logging :\n      - Console : INFO ou DEBUG selon besoin (immÃ©diatement visible)\n      - Fichier : un log par jour avec niveau DEBUG (tout est tracÃ©)",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "send_telegram_alert",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def send_telegram_alert(message: str, force=True):\n    \"\"\"Envoie alerte Telegram seulement pour Ã©vÃ©nements clÃ©s (launch, close bot, open/close position)\"\"\"\n    if not TELEGRAM_TOKEN or not TELEGRAM_CHAT_ID:\n        logging.warning(\"Config Telegram manquante\")\n        return\n    try:\n        bot = Bot(token=TELEGRAM_TOKEN)\n        asyncio.run(bot.send_message(chat_id=TELEGRAM_CHAT_ID, text=message.strip(), parse_mode=\"HTML\"))\n    except Exception as e:\n        logging.error(f\"Ã‰chec Telegram : {e}\")",
        "detail": "utils",
        "documentation": {}
    }
]