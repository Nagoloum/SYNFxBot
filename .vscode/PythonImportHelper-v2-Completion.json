[
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "AccountConfig",
        "importPath": "multi_account",
        "description": "multi_account",
        "isExtraImport": true,
        "detail": "multi_account",
        "documentation": {}
    },
    {
        "label": "streamlit",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "streamlit",
        "description": "streamlit",
        "detail": "streamlit",
        "documentation": {}
    },
    {
        "label": "st_autorefresh",
        "importPath": "streamlit_autorefresh",
        "description": "streamlit_autorefresh",
        "isExtraImport": true,
        "detail": "streamlit_autorefresh",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "plotly.express",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "plotly.express",
        "description": "plotly.express",
        "detail": "plotly.express",
        "documentation": {}
    },
    {
        "label": "plotly.graph_objects",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "plotly.graph_objects",
        "description": "plotly.graph_objects",
        "detail": "plotly.graph_objects",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "MongoClient",
        "importPath": "pymongo",
        "description": "pymongo",
        "isExtraImport": true,
        "detail": "pymongo",
        "documentation": {}
    },
    {
        "label": "MongoClient",
        "importPath": "pymongo",
        "description": "pymongo",
        "isExtraImport": true,
        "detail": "pymongo",
        "documentation": {}
    },
    {
        "label": "ASCENDING",
        "importPath": "pymongo",
        "description": "pymongo",
        "isExtraImport": true,
        "detail": "pymongo",
        "documentation": {}
    },
    {
        "label": "ACCOUNTS",
        "importPath": "accounts_config",
        "description": "accounts_config",
        "isExtraImport": true,
        "detail": "accounts_config",
        "documentation": {}
    },
    {
        "label": "ACCOUNTS",
        "importPath": "accounts_config",
        "description": "accounts_config",
        "isExtraImport": true,
        "detail": "accounts_config",
        "documentation": {}
    },
    {
        "label": "MetaTrader5",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "MetaTrader5",
        "description": "MetaTrader5",
        "detail": "MetaTrader5",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "ACCOUNT_NUMBER",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "PASSWORD",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "SERVER",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "MT5_TERMINAL_PATH",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "MONGODB_URI",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "SYMBOL",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "ACCOUNT_NUMBER",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "SYMBOL",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "MAGIC_NUMBER",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "ACCOUNT_NUMBER",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "MAGIC_NUMBER",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "TELEGRAM_TOKEN",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "TELEGRAM_CHAT_ID",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "send_telegram_alert",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "setup_logging",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "send_telegram_alert",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "DuplicateKeyError",
        "importPath": "pymongo.errors",
        "description": "pymongo.errors",
        "isExtraImport": true,
        "detail": "pymongo.errors",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "init_db",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "save_open",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "save_open",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "save_close",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "save_close",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "save_open",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "connect_to_mt5",
        "importPath": "connexion",
        "description": "connexion",
        "isExtraImport": true,
        "detail": "connexion",
        "documentation": {}
    },
    {
        "label": "disconnect",
        "importPath": "connexion",
        "description": "connexion",
        "isExtraImport": true,
        "detail": "connexion",
        "documentation": {}
    },
    {
        "label": "get_signal",
        "importPath": "strategy",
        "description": "strategy",
        "isExtraImport": true,
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "open_trade",
        "importPath": "strategy",
        "description": "strategy",
        "isExtraImport": true,
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "monitor_active_trade",
        "importPath": "strategy",
        "description": "strategy",
        "isExtraImport": true,
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "is_volatility_good",
        "importPath": "strategy",
        "description": "strategy",
        "isExtraImport": true,
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "prepare_trade_request",
        "importPath": "strategy",
        "description": "strategy",
        "isExtraImport": true,
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "_mt5_lock",
        "importPath": "strategy",
        "description": "strategy",
        "isExtraImport": true,
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "# Mutex partagÃ© entre strategy et main",
        "importPath": "strategy",
        "description": "strategy",
        "isExtraImport": true,
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "pandas_ta",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas_ta",
        "description": "pandas_ta",
        "detail": "pandas_ta",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "asyncio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "asyncio",
        "description": "asyncio",
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "Bot",
        "importPath": "telegram",
        "description": "telegram",
        "isExtraImport": true,
        "detail": "telegram",
        "documentation": {}
    },
    {
        "label": "ACCOUNTS",
        "kind": 5,
        "importPath": "accounts_config",
        "description": "accounts_config",
        "peekOfCode": "ACCOUNTS = [\n    # Compte Principal (chargÃ© depuis .env pour compatibilitÃ©)\n    AccountConfig(\n        account_number=int(os.getenv(\"ACCOUNT_NUMBER\", \"0\")),\n        password=os.getenv(\"PASSWORD\", \"\"),\n        server=os.getenv(\"SERVER\", \"Deriv-Server\"),\n        name=\"Compte Principal\",\n        risk_multiplier=1.0,\n        enabled=True\n    ),",
        "detail": "accounts_config",
        "documentation": {}
    },
    {
        "label": "get_mongo_client",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def get_mongo_client():\n    uri = os.getenv(\"MONGODB_URI\")\n    return MongoClient(uri, serverSelectionTimeoutMS=5000)\ndef get_account_db(client, account_number: int):\n    return client[f\"trading_bot_{account_number}\"]\ndef load_data(client, account_number: int, market_filter: str = \"Tous\") -> pd.DataFrame:\n    db          = get_account_db(client, account_number)\n    collections = db.list_collection_names()\n    all_trades  = []\n    for col_name in collections:",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "get_account_db",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def get_account_db(client, account_number: int):\n    return client[f\"trading_bot_{account_number}\"]\ndef load_data(client, account_number: int, market_filter: str = \"Tous\") -> pd.DataFrame:\n    db          = get_account_db(client, account_number)\n    collections = db.list_collection_names()\n    all_trades  = []\n    for col_name in collections:\n        if market_filter != \"Tous\" and col_name != market_filter:\n            continue\n        trades = list(db[col_name].find().sort(\"open_time\", -1))",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "load_data",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def load_data(client, account_number: int, market_filter: str = \"Tous\") -> pd.DataFrame:\n    db          = get_account_db(client, account_number)\n    collections = db.list_collection_names()\n    all_trades  = []\n    for col_name in collections:\n        if market_filter != \"Tous\" and col_name != market_filter:\n            continue\n        trades = list(db[col_name].find().sort(\"open_time\", -1))\n        for t in trades:\n            t[\"market\"] = col_name",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "df_raw",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "df_raw = load_data(client, selected_account_id, selected_market)\nif df_raw.empty:\n    st.warning(\"Aucune donnÃ©e trouvÃ©e pour ce compte / marchÃ©.\")\n    st.stop()\ndf  = df_raw.copy()\nnow = datetime.now()\nif   periode == \"Aujourd'hui\":\n    start = now.replace(hour=0, minute=0, second=0, microsecond=0)\n    df    = df[df[\"open_time\"] >= start]\nelif periode == \"Hier\":",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "now",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "now = datetime.now()\nif   periode == \"Aujourd'hui\":\n    start = now.replace(hour=0, minute=0, second=0, microsecond=0)\n    df    = df[df[\"open_time\"] >= start]\nelif periode == \"Hier\":\n    start = (now - timedelta(days=1)).replace(hour=0, minute=0, second=0, microsecond=0)\n    end   = now.replace(hour=0, minute=0, second=0, microsecond=0)\n    df    = df[(df[\"open_time\"] >= start) & (df[\"open_time\"] < end)]\nelif periode == \"Cette Semaine\":\n    start = (now - timedelta(days=now.weekday())).replace(hour=0, minute=0, second=0, microsecond=0)",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "closed",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "closed = df[df[\"status\"] == \"CLOSED\"].copy()    # .copy() â†’ Ã©vite SettingWithCopyWarning\nopen_  = df[df[\"status\"] == \"OPEN\"].copy()\nwins   = (closed[\"profit\"] > 0).sum()\nlosses = (closed[\"profit\"] < 0).sum()\nwr     = (wins / len(closed) * 100) if len(closed) > 0 else 0\ntotal_profit = closed[\"profit\"].sum()\navg_win      = closed[closed[\"profit\"] > 0][\"profit\"].mean() if wins > 0  else 0\navg_loss     = closed[closed[\"profit\"] < 0][\"profit\"].mean() if losses > 0 else 0\nprofit_factor = abs(avg_win / avg_loss) if avg_loss != 0 else float(\"inf\")\ncol1, col2, col3, col4, col5 = st.columns(5)",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "losses",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "losses = (closed[\"profit\"] < 0).sum()\nwr     = (wins / len(closed) * 100) if len(closed) > 0 else 0\ntotal_profit = closed[\"profit\"].sum()\navg_win      = closed[closed[\"profit\"] > 0][\"profit\"].mean() if wins > 0  else 0\navg_loss     = closed[closed[\"profit\"] < 0][\"profit\"].mean() if losses > 0 else 0\nprofit_factor = abs(avg_win / avg_loss) if avg_loss != 0 else float(\"inf\")\ncol1, col2, col3, col4, col5 = st.columns(5)\ncol1.metric(\"Trades fermÃ©s\",    len(closed))\ncol2.metric(\"Positions ouvertes\", len(open_))\ncol3.metric(\"Win Rate\",         f\"{wr:.1f}%\")",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "total_profit",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "total_profit = closed[\"profit\"].sum()\navg_win      = closed[closed[\"profit\"] > 0][\"profit\"].mean() if wins > 0  else 0\navg_loss     = closed[closed[\"profit\"] < 0][\"profit\"].mean() if losses > 0 else 0\nprofit_factor = abs(avg_win / avg_loss) if avg_loss != 0 else float(\"inf\")\ncol1, col2, col3, col4, col5 = st.columns(5)\ncol1.metric(\"Trades fermÃ©s\",    len(closed))\ncol2.metric(\"Positions ouvertes\", len(open_))\ncol3.metric(\"Win Rate\",         f\"{wr:.1f}%\")\ncol4.metric(\"Profit Net\",       f\"{total_profit:+.2f} $\")\ncol5.metric(\"Profit Factor\",    f\"{profit_factor:.2f}\")",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "profit_factor",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "profit_factor = abs(avg_win / avg_loss) if avg_loss != 0 else float(\"inf\")\ncol1, col2, col3, col4, col5 = st.columns(5)\ncol1.metric(\"Trades fermÃ©s\",    len(closed))\ncol2.metric(\"Positions ouvertes\", len(open_))\ncol3.metric(\"Win Rate\",         f\"{wr:.1f}%\")\ncol4.metric(\"Profit Net\",       f\"{total_profit:+.2f} $\")\ncol5.metric(\"Profit Factor\",    f\"{profit_factor:.2f}\")\n# â”€â”€ Courbe d'Ã©quitÃ© â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nif not closed.empty and \"close_time\" in closed.columns:\n    closed_sorted = closed.sort_values(\"close_time\")",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "display_cols",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "display_cols = [\n    \"ticket\", \"market\", \"type\", \"open_time\", \"open_price\",\n    \"close_time\", \"close_price\", \"profit\", \"status\"\n]\nfinal_cols = [c for c in display_cols if c in df.columns]\nst.dataframe(\n    df[final_cols].sort_values(\"open_time\", ascending=False),\n    use_container_width=True\n)",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "final_cols",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "final_cols = [c for c in display_cols if c in df.columns]\nst.dataframe(\n    df[final_cols].sort_values(\"open_time\", ascending=False),\n    use_container_width=True\n)",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "ACCOUNT_NUMBER",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "ACCOUNT_NUMBER = int(os.getenv(\"ACCOUNT_NUMBER\", \"0\"))\nPASSWORD = os.getenv(\"PASSWORD\", \"\")\nSERVER = os.getenv(\"SERVER\", \"\")\nMT5_TERMINAL_PATH = r\"C:\\Program Files\\MetaTrader 5\\terminal64.exe\"\nSYMBOL = [\"Volatility 25 Index\", \"Volatility 50 Index\", \"Volatility 75 Index\", \"Volatility 100 Index\"]\nLOT_SIZE = 1.0  # Volume fixe pour le test\nMAGIC_NUMBER = 123456\n# Telegram\nTELEGRAM_TOKEN = os.getenv(\"TELEGRAM_TOKEN\", \"\")\nTELEGRAM_CHAT_ID = os.getenv(\"TELEGRAM_CHAT_ID\", \"\")",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "PASSWORD",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "PASSWORD = os.getenv(\"PASSWORD\", \"\")\nSERVER = os.getenv(\"SERVER\", \"\")\nMT5_TERMINAL_PATH = r\"C:\\Program Files\\MetaTrader 5\\terminal64.exe\"\nSYMBOL = [\"Volatility 25 Index\", \"Volatility 50 Index\", \"Volatility 75 Index\", \"Volatility 100 Index\"]\nLOT_SIZE = 1.0  # Volume fixe pour le test\nMAGIC_NUMBER = 123456\n# Telegram\nTELEGRAM_TOKEN = os.getenv(\"TELEGRAM_TOKEN\", \"\")\nTELEGRAM_CHAT_ID = os.getenv(\"TELEGRAM_CHAT_ID\", \"\")\n# MongoDB",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "SERVER",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "SERVER = os.getenv(\"SERVER\", \"\")\nMT5_TERMINAL_PATH = r\"C:\\Program Files\\MetaTrader 5\\terminal64.exe\"\nSYMBOL = [\"Volatility 25 Index\", \"Volatility 50 Index\", \"Volatility 75 Index\", \"Volatility 100 Index\"]\nLOT_SIZE = 1.0  # Volume fixe pour le test\nMAGIC_NUMBER = 123456\n# Telegram\nTELEGRAM_TOKEN = os.getenv(\"TELEGRAM_TOKEN\", \"\")\nTELEGRAM_CHAT_ID = os.getenv(\"TELEGRAM_CHAT_ID\", \"\")\n# MongoDB\nMONGODB_URI = os.getenv(\"MONGODB_URI\", \"\")",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "MT5_TERMINAL_PATH",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "MT5_TERMINAL_PATH = r\"C:\\Program Files\\MetaTrader 5\\terminal64.exe\"\nSYMBOL = [\"Volatility 25 Index\", \"Volatility 50 Index\", \"Volatility 75 Index\", \"Volatility 100 Index\"]\nLOT_SIZE = 1.0  # Volume fixe pour le test\nMAGIC_NUMBER = 123456\n# Telegram\nTELEGRAM_TOKEN = os.getenv(\"TELEGRAM_TOKEN\", \"\")\nTELEGRAM_CHAT_ID = os.getenv(\"TELEGRAM_CHAT_ID\", \"\")\n# MongoDB\nMONGODB_URI = os.getenv(\"MONGODB_URI\", \"\")\nDB_NAME = os.getenv(\"MONGODB_DB\", \"trading_bot_V100\")",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "SYMBOL",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "SYMBOL = [\"Volatility 25 Index\", \"Volatility 50 Index\", \"Volatility 75 Index\", \"Volatility 100 Index\"]\nLOT_SIZE = 1.0  # Volume fixe pour le test\nMAGIC_NUMBER = 123456\n# Telegram\nTELEGRAM_TOKEN = os.getenv(\"TELEGRAM_TOKEN\", \"\")\nTELEGRAM_CHAT_ID = os.getenv(\"TELEGRAM_CHAT_ID\", \"\")\n# MongoDB\nMONGODB_URI = os.getenv(\"MONGODB_URI\", \"\")\nDB_NAME = os.getenv(\"MONGODB_DB\", \"trading_bot_V100\")\nCOLLECTION_NAME = \"trades_v100\"",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "LOT_SIZE",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "LOT_SIZE = 1.0  # Volume fixe pour le test\nMAGIC_NUMBER = 123456\n# Telegram\nTELEGRAM_TOKEN = os.getenv(\"TELEGRAM_TOKEN\", \"\")\nTELEGRAM_CHAT_ID = os.getenv(\"TELEGRAM_CHAT_ID\", \"\")\n# MongoDB\nMONGODB_URI = os.getenv(\"MONGODB_URI\", \"\")\nDB_NAME = os.getenv(\"MONGODB_DB\", \"trading_bot_V100\")\nCOLLECTION_NAME = \"trades_v100\"",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "MAGIC_NUMBER",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "MAGIC_NUMBER = 123456\n# Telegram\nTELEGRAM_TOKEN = os.getenv(\"TELEGRAM_TOKEN\", \"\")\nTELEGRAM_CHAT_ID = os.getenv(\"TELEGRAM_CHAT_ID\", \"\")\n# MongoDB\nMONGODB_URI = os.getenv(\"MONGODB_URI\", \"\")\nDB_NAME = os.getenv(\"MONGODB_DB\", \"trading_bot_V100\")\nCOLLECTION_NAME = \"trades_v100\"",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "TELEGRAM_TOKEN",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "TELEGRAM_TOKEN = os.getenv(\"TELEGRAM_TOKEN\", \"\")\nTELEGRAM_CHAT_ID = os.getenv(\"TELEGRAM_CHAT_ID\", \"\")\n# MongoDB\nMONGODB_URI = os.getenv(\"MONGODB_URI\", \"\")\nDB_NAME = os.getenv(\"MONGODB_DB\", \"trading_bot_V100\")\nCOLLECTION_NAME = \"trades_v100\"",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "TELEGRAM_CHAT_ID",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "TELEGRAM_CHAT_ID = os.getenv(\"TELEGRAM_CHAT_ID\", \"\")\n# MongoDB\nMONGODB_URI = os.getenv(\"MONGODB_URI\", \"\")\nDB_NAME = os.getenv(\"MONGODB_DB\", \"trading_bot_V100\")\nCOLLECTION_NAME = \"trades_v100\"",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "MONGODB_URI",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "MONGODB_URI = os.getenv(\"MONGODB_URI\", \"\")\nDB_NAME = os.getenv(\"MONGODB_DB\", \"trading_bot_V100\")\nCOLLECTION_NAME = \"trades_v100\"",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "DB_NAME",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "DB_NAME = os.getenv(\"MONGODB_DB\", \"trading_bot_V100\")\nCOLLECTION_NAME = \"trades_v100\"",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "COLLECTION_NAME",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "COLLECTION_NAME = \"trades_v100\"",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "connect_to_mt5",
        "kind": 2,
        "importPath": "connexion",
        "description": "connexion",
        "peekOfCode": "def connect_to_mt5(max_retries=3, delay=5):\n    \"\"\"Connexion MT5 avec retries\"\"\"\n    terminal_path = MT5_TERMINAL_PATH\n    for attempt in range(1, max_retries + 1):\n        try:\n            if mt5.terminal_info():\n                mt5.shutdown()\n                time.sleep(1)\n            # logging.info(f\"Tentative connexion {attempt}/{max_retries}\")\n            if not mt5.initialize(path=terminal_path):",
        "detail": "connexion",
        "documentation": {}
    },
    {
        "label": "disconnect",
        "kind": 2,
        "importPath": "connexion",
        "description": "connexion",
        "peekOfCode": "def disconnect():\n    \"\"\"DÃ©connexion\"\"\"\n    try:\n        if mt5.terminal_info():\n            mt5.shutdown()\n        logging.info(\"Bot arrÃªtÃ©\")\n        send_telegram_alert(\"ğŸ›‘ Bot arrÃªtÃ©\", force=True)  # Alert close\n    except Exception as e:\n        logging.error(f\"Erreur dÃ©connexion : {e}\")",
        "detail": "connexion",
        "documentation": {}
    },
    {
        "label": "DatabaseManager",
        "kind": 6,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "class DatabaseManager:\n    def __init__(self, uri: str):\n        self.client = MongoClient(uri, serverSelectionTimeoutMS=5000)\n        self.uri    = uri\n    def get_db(self, account_number: int):\n        \"\"\"Retourne la base de donnÃ©es propre au compte.\"\"\"\n        return self.client[f\"trading_bot_{account_number}\"]\n    def get_collection(self, account_number: int, symbol: str):\n        \"\"\"\n        Retourne la collection pour un compte + symbole.",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "init_db",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def init_db():\n    \"\"\"Initialise la connexion DB (appelÃ©e au dÃ©marrage du bot).\"\"\"\n    try:\n        mgr = _get_manager()\n        # Test rapide de connectivitÃ©\n        mgr.client.admin.command('ping')\n        logging.info(\"ğŸ’¾ MongoDB connectÃ© avec succÃ¨s\")\n    except Exception as e:\n        logging.error(f\"âŒ Erreur connexion MongoDB : {e}\")\ndef save_open(account_number: int, symbol: str, ticket: int,",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "save_open",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def save_open(account_number: int, symbol: str, ticket: int,\n              type_trade: str, price: float):\n    \"\"\"\n    Enregistre l'ouverture d'un trade.\n    Utilise upsert pour Ã©viter les doublons en cas de retry.\n    \"\"\"\n    try:\n        col = _get_manager().get_collection(account_number, symbol)\n        col.update_one(\n            {\"ticket\": ticket},",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "save_close",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def save_close(account_number: int, symbol: str, ticket: int,\n               profit: float, price: float, status: str = \"CLOSED\"):\n    \"\"\"\n    Enregistre la fermeture d'un trade avec le profit rÃ©el calculÃ©.\n    Si le document n'existe pas (sync tardive), il est crÃ©Ã© via upsert.\n    \"\"\"\n    try:\n        col = _get_manager().get_collection(account_number, symbol)\n        col.update_one(\n            {\"ticket\": ticket},",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "execute_trade",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def execute_trade(symbol: str, signal: dict, multi_manager=None) -> tuple:\n    \"\"\"\n    ExÃ©cute le trade sur un ou plusieurs comptes.\n    Returns: (ticket, lot, account_number)\n    \"\"\"\n    if multi_manager and MODE == \"MULTI\":\n        request, lot, entry_price = prepare_trade_request(symbol, signal)\n        if request is None:\n            return None, 0, None\n        results = multi_manager.execute_trade_all_accounts(request)",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "run_bot_for_symbol",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def run_bot_for_symbol(symbol: str, multi_manager=None):\n    \"\"\"\n    Thread indÃ©pendant d'analyse et de trading pour un symbole.\n    \"\"\"\n    logging.info(f\"ğŸ” DÃ©marrage analyse | {symbol}\")\n    while True:\n        try:\n            # â”€â”€ VÃ©rification connexion MT5 â”€â”€\n            with _mt5_lock:\n                info = mt5.terminal_info()",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "AccountConfig",
        "kind": 6,
        "importPath": "multi_account",
        "description": "multi_account",
        "peekOfCode": "class AccountConfig:\n    \"\"\"Configuration d'un compte MT5.\"\"\"\n    account_number:  int\n    password:        str\n    server:          str\n    name:            str   = \"\"\n    risk_multiplier: float = 1.0   # 1.0 = mÃªme lot que le compte maÃ®tre\n    enabled:         bool  = True\nclass MultiAccountManager:\n    \"\"\"",
        "detail": "multi_account",
        "documentation": {}
    },
    {
        "label": "MultiAccountManager",
        "kind": 6,
        "importPath": "multi_account",
        "description": "multi_account",
        "peekOfCode": "class MultiAccountManager:\n    \"\"\"\n    Gestionnaire multi-comptes MT5.\n    Note : MT5 ne supporte qu'une connexion Ã  la fois par processus.\n    On se reconnecte Ã  chaque opÃ©ration (connect â†’ trade â†’ disconnect).\n    \"\"\"\n    def __init__(self, accounts: List[AccountConfig]):\n        self.accounts            = accounts\n        self.account_info_cache: Dict[int, dict] = {}\n    # â”€â”€ Connexion â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€",
        "detail": "multi_account",
        "documentation": {}
    },
    {
        "label": "_local_lock",
        "kind": 5,
        "importPath": "multi_account",
        "description": "multi_account",
        "peekOfCode": "_local_lock = threading.Lock()\n@dataclass\nclass AccountConfig:\n    \"\"\"Configuration d'un compte MT5.\"\"\"\n    account_number:  int\n    password:        str\n    server:          str\n    name:            str   = \"\"\n    risk_multiplier: float = 1.0   # 1.0 = mÃªme lot que le compte maÃ®tre\n    enabled:         bool  = True",
        "detail": "multi_account",
        "documentation": {}
    },
    {
        "label": "log_step",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def log_step(symbol: str, step: str, message: str, level: str = \"info\"):\n    \"\"\"\n    Affiche chaque Ã©tape d'analyse clairement dans la console.\n    Format : [SYMBOLE           ] [Ã‰TAPE   ] message\n    \"\"\"\n    tag  = f\"[{symbol[:20]:<20}] [{step:<8}]\"\n    full = f\"{tag} {message}\"\n    getattr(logging, level if level in (\"debug\", \"warning\", \"error\") else \"info\")(full)\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# DONNÃ‰ES PRIX",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "get_price_data",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def get_price_data(symbol: str, timeframe: int, bars: int = 200) -> pd.DataFrame:\n    \"\"\"RÃ©cupÃ¨re les donnÃ©es OHLCV.\"\"\"\n    try:\n        rates = mt5.copy_rates_from_pos(symbol, timeframe, 0, bars)\n        if rates is None or len(rates) == 0:\n            return pd.DataFrame()\n        df = pd.DataFrame(rates)\n        df['time'] = pd.to_datetime(df['time'], unit='s')\n        return df\n    except Exception as e:",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "get_current_tick",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def get_current_tick(symbol: str):\n    \"\"\"Retourne le tick courant ou None.\"\"\"\n    try:\n        return mt5.symbol_info_tick(symbol)\n    except Exception as e:\n        logging.error(f\"get_current_tick [{symbol}] : {e}\")\n        return None\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# INDICATEURS\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "calc_ema",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def calc_ema(series: pd.Series, period: int) -> pd.Series:\n    result = ta.ema(series, length=period)\n    return result if result is not None else pd.Series(dtype=float)\ndef calc_atr(df: pd.DataFrame, period: int = ATR_PERIOD) -> pd.Series:\n    result = ta.atr(df['high'], df['low'], df['close'], length=period)\n    return result if result is not None else pd.Series(dtype=float)\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# STOP LEVEL â€” Correction erreur MT5 10016 \"Invalid stops\"\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\ndef get_min_stop_distance(symbol: str) -> float:",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "calc_atr",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def calc_atr(df: pd.DataFrame, period: int = ATR_PERIOD) -> pd.Series:\n    result = ta.atr(df['high'], df['low'], df['close'], length=period)\n    return result if result is not None else pd.Series(dtype=float)\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# STOP LEVEL â€” Correction erreur MT5 10016 \"Invalid stops\"\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\ndef get_min_stop_distance(symbol: str) -> float:\n    \"\"\"\n    Retourne la distance minimale autorisÃ©e pour le SL/TP en prix.\n    MT5 dÃ©finit stops_level en 'points' â†’ conversion en prix.",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "get_min_stop_distance",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def get_min_stop_distance(symbol: str) -> float:\n    \"\"\"\n    Retourne la distance minimale autorisÃ©e pour le SL/TP en prix.\n    MT5 dÃ©finit stops_level en 'points' â†’ conversion en prix.\n    \"\"\"\n    try:\n        info = mt5.symbol_info(symbol)\n        if info is None:\n            return 0.0\n        return info.stops_level * info.point",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "enforce_min_stop",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def enforce_min_stop(symbol: str, entry: float, sl: float, tp: float,\n                     is_buy: bool) -> tuple:\n    \"\"\"\n    Ajuste SL et TP pour respecter la distance minimale MT5 (+ 20% de buffer).\n    Returns: (sl_final, tp_final, sl_dist_finale)\n    \"\"\"\n    min_dist      = get_min_stop_distance(symbol)\n    min_dist_safe = min_dist * 1.2   # Buffer 20%\n    sl_dist = abs(entry - sl)\n    if sl_dist < min_dist_safe:",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "get_dynamic_lot",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def get_dynamic_lot(symbol: str, entry_price: float, sl_price: float,\n                    risk_percent: float = RISK_PER_TRADE) -> float:\n    \"\"\"Calcule le volume pour risquer exactement risk_percent du capital.\"\"\"\n    try:\n        account_info = mt5.account_info()\n        if not account_info:\n            return 0.01\n        balance     = account_info.balance\n        risk_amount = balance * risk_percent\n        distance_sl = abs(entry_price - sl_price)",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "analyze_timeframe",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def analyze_timeframe(symbol: str, timeframe: int) -> str:\n    \"\"\"\n    Analyse la tendance sur un timeframe via EMA20/EMA50.\n    Affiche le rÃ©sultat dans la console.\n    Returns: 'UP' | 'DOWN' | 'NEUTRAL'\n    \"\"\"\n    tf_label = TF_LABELS.get(timeframe, str(timeframe))\n    bars     = TF_BARS.get(timeframe, 200)\n    df = get_price_data(symbol, timeframe, bars)\n    if df.empty or len(df) < EMA_SLOW + 5:",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "detect_ema_crossover_m1",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def detect_ema_crossover_m1(symbol: str) -> dict | None:\n    \"\"\"\n    DÃ©tecte un croisement EMA20/50 sur M1.\n    Calcule SL (1.5Ã—ATR) et TP (2Ã—SL) en respectant le stop level MT5.\n    \"\"\"\n    df = get_price_data(symbol, TF_M1, TF_BARS[TF_M1])\n    if df.empty or len(df) < EMA_SLOW + 10:\n        log_step(symbol, \"M1-SIG\", \"âŒ DonnÃ©es M1 insuffisantes\", level=\"warning\")\n        return None\n    ema20 = calc_ema(df['close'], EMA_FAST)",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "get_signal",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def get_signal(symbol: str) -> dict | None:\n    \"\"\"\n    Analyse complÃ¨te M30 â†’ M15 â†’ M1.\n    La tendance M30 est directrice ; M15 doit Ãªtre alignÃ© avant de chercher le signal M1.\n    \"\"\"\n    logging.info(\"â”€\" * 65)\n    log_step(symbol, \"ANALYSE\", f\"ğŸ” DÃ©but analyse multi-timeframe (M30 â†’ M15 â†’ M1)\")\n    # Ã‰TAPE 1 â€” Tendance M30 (directrice)\n    trend_m30 = analyze_timeframe(symbol, TF_M30)\n    if trend_m30 == 'NEUTRAL':",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "is_volatility_good",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def is_volatility_good(symbol: str) -> tuple:\n    \"\"\"VÃ©rifie si l'ATR M30 est > 70% de sa moyenne â†’ marchÃ© actif.\"\"\"\n    log_step(symbol, \"VOL\", \"VÃ©rification volatilitÃ© (ATR M30)...\")\n    df = get_price_data(symbol, TF_M30, 50)\n    if df.empty:\n        log_step(symbol, \"VOL\", \"âŒ Pas de donnÃ©es M30\", level=\"warning\")\n        return False, \"Pas de donnÃ©es M30\"\n    atr = calc_atr(df, ATR_PERIOD)\n    if atr.empty or len(atr.dropna()) < 5:\n        log_step(symbol, \"VOL\", \"âŒ ATR insuffisant\", level=\"warning\")",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "prepare_trade_request",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def prepare_trade_request(symbol: str, signal: dict) -> tuple:\n    \"\"\"\n    PrÃ©pare la requÃªte MT5 avec SL/TP validÃ©s.\n    Returns: (request_dict, lot, entry_price) ou (None, 0, 0)\n    \"\"\"\n    tick = get_current_tick(symbol)\n    if not tick:\n        log_step(symbol, \"EXEC\", \"âŒ Tick indisponible\", level=\"error\")\n        return None, 0, 0\n    is_buy      = signal['type'] == 'BUY'",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "open_trade",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def open_trade(symbol: str, signal: dict) -> tuple:\n    \"\"\"ExÃ©cute un trade (single-account). Returns: (ticket, lot).\"\"\"\n    request, lot, entry_price = prepare_trade_request(symbol, signal)\n    if request is None:\n        return None, 0\n    log_step(symbol, \"EXEC\", \"ğŸ“¤ Envoi ordre MT5...\")\n    with _mt5_lock:\n        result = mt5.order_send(request)\n    if result is None:\n        log_step(symbol, \"EXEC\", \"âŒ order_send a retournÃ© None\", level=\"error\")",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "modify_sl_tp",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def modify_sl_tp(symbol: str, ticket: int, new_sl: float, new_tp: float) -> bool:\n    \"\"\"Modifie SL et TP d'une position ouverte.\"\"\"\n    request = {\n        \"action\":   mt5.TRADE_ACTION_SLTP,\n        \"symbol\":   symbol,\n        \"position\": ticket,\n        \"sl\":       float(new_sl),\n        \"tp\":       float(new_tp),\n        \"magic\":    MAGIC_NUMBER,\n    }",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "monitor_active_trade",
        "kind": 2,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "def monitor_active_trade(symbol: str, ticket: int, lot: float,\n                          signal: dict, account_number: int = None):\n    \"\"\"Surveillance active avec break-even et trailing stop basÃ© sur ATR.\"\"\"\n    acc_num      = account_number if account_number is not None else ACCOUNT_NUMBER\n    entry_price  = signal.get('_exec_entry', signal['entry_price'])\n    sl_dist      = signal['sl_dist']\n    risk_amount  = sl_dist * lot\n    is_buy       = signal['type'] == 'BUY'\n    breakeven_ok = False\n    best_price   = entry_price",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "TF_M30",
        "kind": 5,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "TF_M30 = mt5.TIMEFRAME_M30\nTF_M15 = mt5.TIMEFRAME_M15\nTF_M1  = mt5.TIMEFRAME_M1\nTF_LABELS = {\n    TF_M30: \"M30\",\n    TF_M15: \"M15\",\n    TF_M1:  \"M1\",\n}\nTF_BARS = {\n    TF_M30: 200,",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "TF_M15",
        "kind": 5,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "TF_M15 = mt5.TIMEFRAME_M15\nTF_M1  = mt5.TIMEFRAME_M1\nTF_LABELS = {\n    TF_M30: \"M30\",\n    TF_M15: \"M15\",\n    TF_M1:  \"M1\",\n}\nTF_BARS = {\n    TF_M30: 200,\n    TF_M15: 200,",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "TF_LABELS",
        "kind": 5,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "TF_LABELS = {\n    TF_M30: \"M30\",\n    TF_M15: \"M15\",\n    TF_M1:  \"M1\",\n}\nTF_BARS = {\n    TF_M30: 200,\n    TF_M15: 200,\n    TF_M1:  150,\n}",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "TF_BARS",
        "kind": 5,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "TF_BARS = {\n    TF_M30: 200,\n    TF_M15: 200,\n    TF_M1:  150,\n}\nEMA_FAST       = 20\nEMA_SLOW       = 50\nATR_PERIOD     = 14\nATR_SL_MULT    = 1.5\nATR_TRAIL_MULT = 1.0",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "ATR_TRAIL_MULT",
        "kind": 5,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "ATR_TRAIL_MULT = 1.0\nRR_RATIO       = 2.0\nRISK_PER_TRADE = 0.02\nBREAKEVEN_R    = 1.0\n# Mutex global MT5 â€” partagÃ© avec main.py et multi_account.py\n_mt5_lock = threading.Lock()\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# LOGGING HELPER\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\ndef log_step(symbol: str, step: str, message: str, level: str = \"info\"):",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "RISK_PER_TRADE",
        "kind": 5,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "RISK_PER_TRADE = 0.02\nBREAKEVEN_R    = 1.0\n# Mutex global MT5 â€” partagÃ© avec main.py et multi_account.py\n_mt5_lock = threading.Lock()\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# LOGGING HELPER\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\ndef log_step(symbol: str, step: str, message: str, level: str = \"info\"):\n    \"\"\"\n    Affiche chaque Ã©tape d'analyse clairement dans la console.",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "_mt5_lock",
        "kind": 5,
        "importPath": "strategy",
        "description": "strategy",
        "peekOfCode": "_mt5_lock = threading.Lock()\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# LOGGING HELPER\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\ndef log_step(symbol: str, step: str, message: str, level: str = \"info\"):\n    \"\"\"\n    Affiche chaque Ã©tape d'analyse clairement dans la console.\n    Format : [SYMBOLE           ] [Ã‰TAPE   ] message\n    \"\"\"\n    tag  = f\"[{symbol[:20]:<20}] [{step:<8}]\"",
        "detail": "strategy",
        "documentation": {}
    },
    {
        "label": "sync_account",
        "kind": 2,
        "importPath": "sync_history",
        "description": "sync_history",
        "peekOfCode": "def sync_account(account_config, days: int = 30):\n    \"\"\"Synchronise l'historique d'un compte vers MongoDB.\"\"\"\n    logging.info(\n        f\"ğŸ”„ Synchronisation {account_config.name} ({account_config.account_number})...\"\n    )\n    # â”€â”€ Connexion â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n    if not mt5.initialize():\n        logging.error(\"âŒ Erreur init MT5\")\n        return\n    if not mt5.login(account_config.account_number,",
        "detail": "sync_history",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "sync_history",
        "description": "sync_history",
        "peekOfCode": "def main():\n    print(\"=== SYNCHRONISATION DU JOURNAL DE TRADING ===\")\n    print(\"Parcourt tous les comptes configurÃ©s et met Ã  jour MongoDB.\")\n    print(\"âš ï¸ ArrÃªtez le bot avant de lancer cette synchronisation.\")\n    confirm = input(\"Tapez 'O' pour continuer : \")\n    if confirm.strip().lower() != \"o\":\n        print(\"AnnulÃ©.\")\n        return\n    for account in ACCOUNTS:\n        if account.enabled:",
        "detail": "sync_history",
        "documentation": {}
    },
    {
        "label": "modules_required",
        "kind": 5,
        "importPath": "test_installation",
        "description": "test_installation",
        "peekOfCode": "modules_required = [\n    \"MetaTrader5\",\n    \"pandas\",\n    \"pandas_ta\",\n    \"numpy\",\n    \"pymongo\",\n    \"python-dotenv\",\n    \"telegram\",\n    \"streamlit\",\n]",
        "detail": "test_installation",
        "documentation": {}
    },
    {
        "label": "missing_modules",
        "kind": 5,
        "importPath": "test_installation",
        "description": "test_installation",
        "peekOfCode": "missing_modules = []\nfor module_name in modules_required:\n    try:\n        if module_name == \"python-dotenv\":\n            import dotenv\n            print(f\"  âœ… {module_name}\")\n        elif module_name == \"MetaTrader5\":\n            import MetaTrader5 as mt5\n            print(f\"  âœ… {module_name}\")\n        elif module_name == \"pandas_ta\":",
        "detail": "test_installation",
        "documentation": {}
    },
    {
        "label": "required_files",
        "kind": 5,
        "importPath": "test_installation",
        "description": "test_installation",
        "peekOfCode": "required_files = [\n    \"main.py\",\n    \"strategy.py\",\n    \"config.py\",\n    \"connexion.py\",\n    \"database.py\",\n    \"utils.py\",\n    \"multi_account.py\",\n    \"accounts_config.py\",\n    \"requirements.txt\",",
        "detail": "test_installation",
        "documentation": {}
    },
    {
        "label": "setup_logging",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def setup_logging(\n    level=logging.INFO,\n    console_level=logging.INFO,      # niveau pour la console (peut Ãªtre plus verbeux)\n    file_level=logging.DEBUG,        # niveau pour le fichier (plus dÃ©taillÃ©)\n    log_dir=\"logs\"\n):\n    \"\"\"\n    Configure le logging :\n      - Console : INFO ou DEBUG selon besoin (immÃ©diatement visible)\n      - Fichier : un log par jour avec niveau DEBUG (tout est tracÃ©)",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "send_telegram_alert",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def send_telegram_alert(message: str, force=True):\n    \"\"\"Envoie alerte Telegram seulement pour Ã©vÃ©nements clÃ©s (launch, close bot, open/close position)\"\"\"\n    if not TELEGRAM_TOKEN or not TELEGRAM_CHAT_ID:\n        logging.warning(\"Config Telegram manquante\")\n        return\n    try:\n        bot = Bot(token=TELEGRAM_TOKEN)\n        asyncio.run(bot.send_message(chat_id=TELEGRAM_CHAT_ID, text=message.strip(), parse_mode=\"HTML\"))\n    except Exception as e:\n        logging.error(f\"Ã‰chec Telegram : {e}\")",
        "detail": "utils",
        "documentation": {}
    }
]